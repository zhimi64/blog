<!doctype html>
<html lang="" itemscope itemtype="http://schema.org/Person">
<head>

  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G3N739QVFZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-G3N739QVFZ');
  </script>
  

  
  <script>
    window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
  </script>
  <script defer src="./_vercel/insights/script.js"></script>
  

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  
  

<!-- Quarto -->
<link href="./theme/css/quarto/quarto.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>
<script src="./theme/scripts/quarto/quarto.js"></script>


  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>Lean语言数学之旅——命題邏輯</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="介紹了如何在Lean中證明一個定理。命題邏輯涉及命題與命題之間的關係，有時又被稱為零階邏輯。命題指的是一個可以判斷真假的陳述句，根據其真假命題可以分為真命題或假命題。本章介紹了命題邏輯的與、或、非運算在Lean中的實現以及應用方式。文章給出了一些可供練習的習題和參考答案。">
  <meta name="author" content="執迷">

  <link rel="shortcut icon" href="favicon.ico">

  <!-- schema.org -->
  <meta itemprop="name" content="執迷的博客">
  <meta itemprop="image" content="">
  <meta itemprop="description" content="介紹了如何在Lean中證明一個定理。命題邏輯涉及命題與命題之間的關係，有時又被稱為零階邏輯。命題指的是一個可以判斷真假的陳述句，根據其真假命題可以分為真命題或假命題。本章介紹了命題邏輯的與、或、非運算在Lean中的實現以及應用方式。文章給出了一些可供練習的習題和參考答案。">

  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
  <!-- Style Meta Data -->
  <link rel="stylesheet" href="https://zhimi.vercel.app/theme/css/style.css" type="text/css" />
  <link rel="stylesheet" href="https://zhimi.vercel.app/theme/css/pygments.css" type="text/css" />

  <!-- Feed Meta Data -->
  
  
    <link href="https://zhimi.vercel.app/https://zhimi.vercel.app/feeds/rss.xml" type="application/atom+xml" rel="alternate" title="執迷的博客 RSS Feed" />
  

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="">
  
<meta name="twitter:creator" content="">
<meta name="twitter:url" content="https://zhimi.vercel.app/./lean_logic_20250111.html">
<meta name="twitter:title" content="執迷的博客 ~ Lean语言数学之旅——命題邏輯">
<meta name="twitter:description" content="">

<!-- Facebook Meta Data -->
<meta property="og:title" content="執迷的博客 ~ Lean语言数学之旅——命題邏輯" />
<meta property="og:description" content="" />
<meta property="og:image" content="" />


<!-- MathJax -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>




</head>

<body>
  <!-- Sidebar -->
  <aside>
    <!--<center><a href="https://zhimi.vercel.app"><img id="avatar" src=""></a></center>-->
    <h1>執迷的博客</h1>
    
      <p>做一個有趣的人！</p>
    
    <br>

    

    <nav class="nav">
      <ul class="list-bare">
      
        
          <li><a class="nav__link" href="https://zhimi.vercel.app/index.html">Blog</a></li>
        
         
        
          <li><a class="nav__link" href="https://zhimi.vercel.app/./about.html">About</a></li>
        
         
      </ul>
    </nav>

    <p class="social">
      
      
      
      <a href="https://zhimi.vercel.app/https://zhimi.vercel.app/feeds/rss.xml" rel="alternate">
        <img src="https://zhimi.vercel.app/theme/images/icons/rss.png"></a>
      
    </p>

    <!--
    
    -->
  </aside>

  <!-- Content -->
  <article>
    
<section id="content">
    <h2 class="post_title post_detail"><a href="https://zhimi.vercel.app/./lean_logic_20250111.html" rel="bookmark" title="Permalink to Lean语言数学之旅——命題邏輯">Lean语言数学之旅——命題邏輯</a></h2>
    
    <p>
        <span id="busuanzi_container_page_pv">
            本文瀏覽次數<span id="busuanzi_value_page_pv"></span>
        </span>
    </p>
    
    <div class="entry-content blog-post">
        <div>
<div class="page-columns page-rows-contents page-layout-article" id="quarto-content">
<div class="sidebar margin-sidebar" id="quarto-margin-sidebar">
<nav class="toc-active" id="TOC" role="doc-toc">
<h2 id="toc-title">目录</h2>
<ul>
<li><a class="nav-link active" data-scroll-target="#命題邏輯" href="#命題邏輯" id="toc-命題邏輯"><span class="header-section-number">1</span> 命題邏輯</a></li>
<li><a class="nav-link" data-scroll-target="#命題的證明" href="#命題的證明" id="toc-命題的證明"><span class="header-section-number">2</span> 命題的證明</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#公理" href="#公理" id="toc-公理"><span class="header-section-number">2.1</span> 公理</a></li>
<li><a class="nav-link" data-scroll-target="#類型即命題" href="#類型即命題" id="toc-類型即命題"><span class="header-section-number">2.2</span> 類型即命題</a></li>
<li><a class="nav-link" data-scroll-target="#編寫證明" href="#編寫證明" id="toc-編寫證明"><span class="header-section-number">2.3</span> 編寫證明</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#與運算" href="#與運算" id="toc-與運算"><span class="header-section-number">2.3.1</span> 與運算</a></li>
<li><a class="nav-link" data-scroll-target="#或運算" href="#或運算" id="toc-或運算"><span class="header-section-number">2.3.2</span> 或運算</a></li>
<li><a class="nav-link" data-scroll-target="#非運算" href="#非運算" id="toc-非運算"><span class="header-section-number">2.3.3</span> 非運算</a></li>
<li><a class="nav-link" data-scroll-target="#等價關係" href="#等價關係" id="toc-等價關係"><span class="header-section-number">2.3.4</span> 等價關係</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#一些有用的工具" href="#一些有用的工具" id="toc-一些有用的工具"><span class="header-section-number">2.4</span> 一些有用的工具</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#show關鍵詞" href="#show關鍵詞" id="toc-show關鍵詞"><span class="header-section-number">2.4.1</span> <code>show</code>關鍵詞</a></li>
<li><a class="nav-link" data-scroll-target="#let關鍵詞" href="#let關鍵詞" id="toc-let關鍵詞"><span class="header-section-number">2.4.2</span> <code>let</code>關鍵詞</a></li>
<li><a class="nav-link" data-scroll-target="#have關鍵詞" href="#have關鍵詞" id="toc-have關鍵詞"><span class="header-section-number">2.4.3</span> <code>have</code>關鍵詞</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#練習一" href="#練習一" id="toc-練習一"><span class="header-section-number">2.5</span> 練習一</a></li>
<li><a class="nav-link" data-scroll-target="#練習二-經典邏輯" href="#練習二-經典邏輯" id="toc-練習二-經典邏輯"><span class="header-section-number">2.6</span> 練習二-經典邏輯</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#總結" href="#總結" id="toc-總結"><span class="header-section-number">3</span> 總結</a></li>
</ul>
</nav>
</div>
<main class="content" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header">
<div class="quarto-title">

</div>
<div class="quarto-title-meta">
<div>
<div class="quarto-title-meta-heading">发布于</div>
<div class="quarto-title-meta-contents">
<p class="date">2025年1月12日</p>
</div>
</div>
</div>
</header>
<div class="hidden">
<link href="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/styles/default.min.css" rel="stylesheet"/>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
<script src="https://unpkg.com/highlightjs-lean/dist/lean.min.js" type="text/javascript"></script>
<script type="text/javascript">
  hljs.highlightAll();
</script>
<style>
.lean {background-color: GhostWhite;}
</style>
</div>
<p>上一章介紹了Lean的一些基本概念和環境配置。本章開始，我們將介紹如何證明一個定理。讓我們先從基礎的命題邏輯開始。</p>
<section class="level1" data-number="1" id="命題邏輯">

<p>命題邏輯涉及命題與命題之間的關係，有時又被稱為零階邏輯。</p>
<p>命題指的是一個可以判斷真假的陳述句，根據其真假命題可以分為真命題或假命題。例如</p>
<ul>
<li>√2是無理數</li>
<li>有無窮多個自然數</li>
<li>矩陣乘法沒有交換律</li>
<li>2012年，世界末日到來</li>
</ul>
<p>以上各種陳述句或真或假，都屬於命題。</p>
<pre class="lean"><code>section
  variable (p q r : Prop)</code></pre>
<p>在Lean中，命題的類型為<code>Prop</code>。上面的代碼聲明了三個參數，分別是命題p、q和r。</p>
<p>定義在命題上的基本運算包括與運算、或運算、非運算等。在Lean中，<code>And</code>運算即命題的與運算：</p>
<pre class="lean"><code>  #check And     -- 與運算
  -- 輸出為：And (a b : Prop) : Prop
  #check And p q -- 表示p和q都是真命題
  #check p ∧ q   -- And p q 的另一種寫法</code></pre>
<p>上面的代碼中演示了“與”的運算，其中<code>#check</code>用於輸出算式的類型。與運算可以使用<code>And</code>或<code>∧</code>符號構造，符號<code>∧</code>可以在編輯器中用<code>\and</code>打出。</p>
<p>類似的，下面是或運算、非運算等運算的用法。</p>
<pre class="lean"><code>  #check Or     -- 或運算
  -- 輸出為：Or (a b : Prop) : Prop
  #check Or p q -- 表示p或q其中之一是真命題
  #check p ∨ q  -- Or p q 的另一種寫法
  -- ∨ 可以在編輯器中用\or打出

  #check Not    -- 非
  #check Not p  -- 表示p是假命題
  #check ¬p     -- Not p 的另一種寫法
  -- ¬ 可以在編輯器中用\not打出

  #check p → q  -- 蘊含關係，表示如果p為真，那麼q也為真
  -- → 可以在編輯器中用\to或者\r打出
  #check p ↔ q  -- 表示p成立當且僅當q成立
  -- ↔ 可以在編輯器中用\lr打出

end</code></pre>
</section>
<section class="level1" data-number="2" id="命題的證明">

<section class="level2" data-number="2.1" id="公理">
<h2 class="anchored" data-anchor-id="公理" data-number="2.1"><span class="header-section-number">2.1</span> 公理</h2>
<p>公理是不言自明的真命題，是不需要證明的。</p>
<p>下面的例子中，我在<code>crazy_axioms</code>命名空間下聲明了一個公理：</p>
<pre class="lean"><code>namespace crazy_axioms
  -- 聲明了一個命題p
  variable (p : Prop)
  -- 聲明了一個公理em
  -- 該公理的含義是：對於任意的命題p，p要麼為真，要麼為假。
  -- 它被叫做排中律（Law Of Excluded Middle）
  axiom em : p ∨ ¬p
end crazy_axioms

#check crazy_axioms.em
-- 類型為：em (p : Prop) : p ∨ ¬p</code></pre>
<p>公理em的類型是<code>p ∨ ¬p</code>，表示對於任意的命題p，p要麼為真，要麼為假。</p>
<p>我不提供em的證明，因為它是公理。你可以拒絕一個公理或者接受一個公理，可以討論一個公理的引入是否合理。但只要我們引入了它，就默認它是真的。</p>
<p>我將其放在crazy_axioms命名空間下。如果不想使用這個公理，你需要避免在代碼中使用crazy_axioms這個命名空間。</p>
</section>
<section class="level2" data-number="2.2" id="類型即命題">
<h2 class="anchored" data-anchor-id="類型即命題" data-number="2.2"><span class="header-section-number">2.2</span> 類型即命題</h2>
<p>接下來說明如何在Lean中證明一個命題為真。</p>
<p>在Lean中，命題也是一種類型。<strong>對於任意命題，如果你能構造類型為該命題的實例，就相當於證明這個命題為真。</strong></p>
<p>下面將展示一些具體的例子。我們要證明：</p>
<pre class="lean"><code>section
  variable (p : Prop)
  example : ¬p ∨ ¬¬p := sorry
end</code></pre>
<p>在Lean中，作為練習，我們經常會證明一些不重要的定理，我們懶得給它們取名字，這時我們使用<code>example</code>.</p>
<p>我們暫時沒有給出<code>¬p ∨ ¬¬p</code>的證明，因此我們將證明設為<code>sorry</code>，表示我們暫時給不了證明，但是請Lean不要報錯。</p>
<p>上面的寫法也等價於：</p>
<pre class="lean"><code>example (p : Prop) : ¬p ∨ ¬¬p := sorry</code></pre>
<p>即可以將變量p的聲明與定理合併在一行。</p>
<p>加下來我們給出如何證明。<code>p</code>是一個命題，因此<code>p</code>的否定<code>¬p</code>也是一個命題。假如我們將其應用於em公理，將會得到什麼呢？</p>
<pre class="lean"><code>section
  variable (p : Prop)
  #check crazy_axioms.em ¬p -- crazy_axioms.em ¬p : ¬p ∨ ¬¬p
end</code></pre>
<p>我們得到了一個類型為<code>¬p ∨ ¬¬p</code>的實例。因此，它可以作為<code>¬p ∨ ¬¬p</code>的證明。</p>
<pre class="lean"><code>example {p : Prop} : ¬p ∨ ¬¬p := crazy_axioms.em ¬p</code></pre>
<p>在Lean中，我們使用<code>theorem</code>來定義定理。<code>theorem</code>就是有名字的<code>example</code>。</p>
<pre class="lean"><code>theorem np_or_nnp {p : Prop} : ¬p ∨ ¬¬p := crazy_axioms.em ¬p
#check np_or_nnp -- 類型為 ¬p ∨ ¬¬p</code></pre>
<p>我們將得到的新命題命名為np_or_nnp，這實際上是一個返回類型為<code>¬p ∨ ¬¬p</code>的函數，我們用<code>crazy_axioms.em ¬p</code>作為它的返回值。</p>
<p>綜上所述，我們這麼理解Lean中的證明過程： 一條定理實際上是一個函數。這個函數的輸入是定理使用的變量或者前提，輸出類型是定理所對應的命題，我們需要構造一個滿足類型要求的返回值作為其證明。</p>
<p>類型的證明也並不總是需要引用公理或先前的命題。下面是一個例子。</p>
<pre class="lean"><code>example {p q: Prop} : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp</code></pre>
<p>在這個例子中，我們需要構造一個類型為<code>p → q → p</code>的值。</p>
<p>注意Lean中，<code>→</code>符號是右結合的，所以<code>p → q → p</code>表示的是<code>p → (q → p)</code>. 函數<code>fun hp : p =&gt; fun hq : q =&gt; hp</code>的類型恰為<code>p → q → p</code>，這就完成了證明。</p>
<p>注意如果函數的輸入類型為<code>a</code>，輸出類型為<code>b</code>，那麼函數的類型為<code>a → b</code>，恰好對應著“<code>a</code>蘊含<code>b</code>”這一命題。</p>
<p>接下來，讓我們正式著手證明一些命題。</p>
</section>
<section class="level2" data-number="2.3" id="編寫證明">
<h2 class="anchored" data-anchor-id="編寫證明" data-number="2.3"><span class="header-section-number">2.3</span> 編寫證明</h2>
<section class="level3" data-number="2.3.1" id="與運算">
<h3 class="anchored" data-anchor-id="與運算" data-number="2.3.1"><span class="header-section-number">2.3.1</span> 與運算</h3>
<p><code>p ∧ q</code>表示命題p和命題q同時成立，其定義為：</p>
<pre class="lean"><code>#print And
-- 輸出：
-- structure And (a b : Prop) : Prop
-- number of parameters: 2
-- fields:
--   And.left : a
--   And.right : b
-- constructor:
--   And.intro {a b : Prop} (left : a) (right : b) : a ∧ b</code></pre>
<p>可見<code>And</code>是一個結構體，包含<code>left</code>和<code>right</code>兩個字段，並且有一個構造函數<code>And.intro</code>.</p>
<p><code>And.left</code>的用法如下：</p>
<div class="theorem example" id="exm-and-left">
<p><span class="theorem-title"><strong>例 1</strong></span> <strong>And.left</strong></p>
<pre class="lean"><code>example {p q : Prop} : p ∧ q → p := fun h : p ∧ q =&gt; h.left</code></pre>
<p>這個例子中，<code>h</code>的類型為<code>And p q</code>，因此<code>h.left</code>的類型為<code>p</code>.</p>
<p>上面的證明也可以寫成：</p>
<pre class="lean"><code>example {p q : Prop} : p ∧ q → p := fun h : p ∧ q =&gt; And.left h</code></pre>
</div>
<p>接下來，請仿照<code>And.left</code>的用法，使用<code>And.right</code>完成練習。</p>
<div class="theorem exercise" id="exr-and-right">
<p><span class="theorem-title"><strong>习题 1</strong></span>  </p>
證明<code>p ∧ q → q</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∧ q → q := fun h =&gt; h.right</code></pre>
</details>
</div>
<div class="theorem example" id="exm-and-intro">
<p><span class="theorem-title"><strong>例 2</strong></span> <strong>And.intro</strong></p>
<p><code>And.intro</code>是<code>And</code>的構造函數，其用法如下：</p>
<pre class="lean"><code>example  {p q : Prop} : p → q → p ∧ q :=
  fun hp : p =&gt;
    fun hq : q =&gt;
      And.intro hp hq</code></pre>
</div>
<p>該例子表明給定條件<code>p</code>和<code>q</code>成立，就有<code>p ∧ q</code>成立。</p>
<div class="theorem exercise" id="exr-and-intro">
<p><span class="theorem-title"><strong>习题 2</strong></span> <strong>And的交換律</strong></p>
證明：<code>p ∧ q → q ∧ p</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example  {p q : Prop} : p ∧ q → q ∧ p :=
  fun h : p ∧ q =&gt;
    And.intro h.right h.left</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-and-idempotent">
<p><span class="theorem-title"><strong>习题 3</strong></span> <strong>And的冪等律</strong></p>
證明：<code>p ∧ p → p</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example  {p : Prop} : p ∧ p → p :=
  fun h : p ∧ p =&gt;
    h.left</code></pre>
</details>
</div>
</section>
<section class="level3" data-number="2.3.2" id="或運算">
<h3 class="anchored" data-anchor-id="或運算" data-number="2.3.2"><span class="header-section-number">2.3.2</span> 或運算</h3>
<p><code>p ∨ q</code>表示命題p或命題q其中之一成立，或運算的定義為：</p>
<pre class="lean"><code>#print Or
-- inductive Or : Prop → Prop → Prop
-- number of parameters: 2
-- constructors:
-- Or.inl : ∀ {a b : Prop}, a → a ∨ b
-- Or.inr : ∀ {a b : Prop}, b → a ∨ b</code></pre>
<p>可以看到<code>Or</code>有兩種構造函數，<code>inl</code>和<code>inr</code>。以<code>inl</code>為例，其含義為：若命題<code>a</code>成立，則命題<code>a ∨ b</code>成立。同理可知<code>inr</code>的用法。</p>
<div class="theorem example" id="exm-or-inl">
<p><span class="theorem-title"><strong>例 3</strong></span> <strong>Or.inl</strong></p>
<pre class="lean"><code>example {p q : Prop} : p → p ∨ q :=
  fun hp : p =&gt; Or.inl hp</code></pre>
</div>
<p>仿照這些例子，你可以完成下面的這些練習。</p>
<div class="theorem exercise" id="exr-or-inr">
<p><span class="theorem-title"><strong>习题 4</strong></span>  </p>
證明：<code>q → p ∨ q</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : q → p ∨ q :=
  fun hq : q =&gt; Or.inr hq</code></pre>
</details>
</div>
<p><code>p ∨ q</code>表明<code>p</code>和<code>q</code>中至少有一個為真，因此在證明過程中我們常常需要分情況討論。對應的定理在Lean中為<code>Or.elim</code>. <code>Or.elim</code>的定義為：</p>
<pre class="lean"><code>#check Or.elim
-- Or.elim {a b c : Prop} (h : a ∨ b) (left : a → c) (right : b → c) : c</code></pre>
<p>即已知<code>a</code>和<code>b</code>中至少有一個為真，且分兩種情況討論都能推出<code>c</code>為真，那麼<code>c</code>是真命題。</p>
<p><code>Or.elim</code>的用法舉例如下：</p>
<div class="theorem exercise" id="exr-or-comm">
<p><span class="theorem-title"><strong>习题 5</strong></span>  </p>
<strong>或運算的交換律：</strong>證明: <code>p ∨ q → q ∨ p</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∨ q → q ∨ p :=
  fun hpq : p ∨ q =&gt;
    Or.elim hpq
      ( -- 假如p為真
        fun hp : p =&gt;
          Or.inr hp
      )
      ( -- 假如q為真
        fun hq : q =&gt;
          Or.inl hq
      )</code></pre>
</details>
</div>
</section>
<section class="level3" data-number="2.3.3" id="非運算">
<h3 class="anchored" data-anchor-id="非運算" data-number="2.3.3"><span class="header-section-number">2.3.3</span> 非運算</h3>
<p>Lean定義了兩個特殊的命題，<code>True</code>和<code>False</code>. 它們分別代表真命題和假命題。</p>
<pre class="lean"><code>#check True  -- Prop
#check False -- Prop</code></pre>
<p>在Lean中，非運算的定義比較特別——它被定義為一個函數：</p>
<pre class="lean"><code>#print Not
-- def Not : Prop → Prop :=
-- fun a =&gt; a → False</code></pre>
<p>由Not的定義可見，非運算被定義為一個返回False命題的函數。即，如果<code>Not p</code>（或<code>¬p</code>）為真，那麼我們以<code>p</code>為前提應該能得到一個假命題。</p>
<pre class="lean"><code>example {p q : Prop} : ¬p → ¬(p ∧ q) :=
  -- 當前目標為證明 ¬p → ¬(p ∧ q)
  fun hnp : ¬p =&gt;
    -- 此時目標為證明¬(p ∧ q)，等同於(p ∧ q) → False
    fun hpq : p ∧ q =&gt;
      -- 目標為`False`
      hnp hpq.left
      -- 👆hnp輸入為`p`類型時，能返回False。我們利用這一點完成證明</code></pre>
<p>注意在這個例子中，<code>hnp</code>被當做一個函數使用，用於返回<code>False</code>類型。</p>
</section>
<section class="level3" data-number="2.3.4" id="等價關係">
<h3 class="anchored" data-anchor-id="等價關係" data-number="2.3.4"><span class="header-section-number">2.3.4</span> 等價關係</h3>
<p>當<code>p ↔︎ q</code>是，我們說<code>p</code>與<code>q</code>等價，或者<code>p</code>成立當且僅當<code>q</code>成立。等價關係被定義為：</p>
<pre class="lean"><code>#print Iff
-- structure Iff (a b : Prop) : Prop
-- number of parameters: 2
-- fields:
--   Iff.mp : a → b
--   Iff.mpr : b → a
-- constructor:
--   Iff.intro {a b : Prop} (mp : a → b) (mpr : b → a) : a ↔ b</code></pre>
<p>可以看到<code>Iff</code>是一個結構體，包含<code>mp</code>和<code>mpr</code>兩個字段，並且有一個構造函數<code>Iff.intro</code>.</p>
<p><code>Iff.mp (p ↔︎ q)</code>，也可以寫成<code>(p ↔︎ q).mp</code>，表示有<code>p → q</code>成立，即<code>p</code>為真時，<code>q</code>為真。反之<code>Iff.mpr (p ↔︎ q)</code>的箭頭方向相反，表示<code>q → p</code>成立。</p>
<p><code>Iff.intro</code>的用法如下：</p>
<pre class="lean"><code>example {p q : Prop} : (p → q) → (q → p) → (p ↔ q) :=
  fun hpq : (p → q) =&gt;
    fun hqp : (q → p) =&gt;
      Iff.intro hpq hqp</code></pre>
</section>
</section>
<section class="level2" data-number="2.4" id="一些有用的工具">
<h2 class="anchored" data-anchor-id="一些有用的工具" data-number="2.4"><span class="header-section-number">2.4</span> 一些有用的工具</h2>
<section class="level3" data-number="2.4.1" id="show關鍵詞">
<h3 class="anchored" data-anchor-id="show關鍵詞" data-number="2.4.1"><span class="header-section-number">2.4.1</span> <code>show</code>關鍵詞</h3>
<p>在Lean中，我們可以使用<code>show</code>關鍵詞來指定我們要證明的類型。例如，</p>
<pre class="lean"><code>example {p q : Prop} : ¬p → ¬(p ∧ q) :=
  fun hnp : ¬p =&gt;
    show p ∧ q → False from
    fun hpq : p ∧ q =&gt;
      show False from hnp hpq.left</code></pre>
<p><code>show</code>的用處是增加我們代碼的可讀性。將當前證明目標顯式展現出來。</p>
</section>
<section class="level3" data-number="2.4.2" id="let關鍵詞">
<h3 class="anchored" data-anchor-id="let關鍵詞" data-number="2.4.2"><span class="header-section-number">2.4.2</span> <code>let</code>關鍵詞</h3>
<p><code>let</code>關鍵詞用於局部變量的聲明。例如，</p>
<pre class="lean"><code>example {p q : Prop} (h : p ∧ q) : q ∧ p :=
  let hp : p := h.left
  let hq : q := h.right
  show q ∧ p from And.intro hq hp</code></pre>
<p>在這個函數中，我們定義了<code>hp</code>和<code>hq</code>這兩個局部變量。</p>
</section>
<section class="level3" data-number="2.4.3" id="have關鍵詞">
<h3 class="anchored" data-anchor-id="have關鍵詞" data-number="2.4.3"><span class="header-section-number">2.4.3</span> <code>have</code>關鍵詞</h3>
<p>在Lean中，我們可以使用<code>have</code>關鍵詞聲明和完成一些中間步驟的證明。例如，</p>
<pre class="lean"><code>example {p q : Prop} (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  have hq : q := h.right
  show q ∧ p from And.intro hq hp</code></pre>
<p>在這個例子中，<code>hp</code>和<code>hq</code>是完成最終證明所需的中間步驟。</p>
<p>實際上<code>have</code>關鍵詞是一種語法糖。<code>have h : p := s; t</code>等價於<code>(fun (h : p) =&gt; t) s</code>. 因此，上面的代碼等價於：</p>
<pre class="lean"><code>example {p q : Prop} (h : p ∧ q) : q ∧ p :=
    (fun (hp : p) =&gt;
      (
        fun (hq : q) =&gt;
          show q ∧ p from And.intro hq hp
      ) h.right
    ) h.left</code></pre>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
注记
</div>
</div>
<div class="callout-body-container callout-body">
<p>請注意聲明中間步驟的<code>have</code>和聲明局部變量的<code>let</code>之間的差異，思考它們有什麼區別。</p>
</div>
</div>
</section>
</section>
<section class="level2" data-number="2.5" id="練習一">
<h2 class="anchored" data-anchor-id="練習一" data-number="2.5"><span class="header-section-number">2.5</span> 練習一</h2>
<p>在證明下列命題時，請不要使用排中律，即（p ∨ ¬p）。</p>
<p>儘管在經典邏輯中，我們認為一個命題要麼為真要麼為假（排中律）；但也有一些人並不認可排中律，認為也應允許非真非假的命題存在。實際上，不依賴排中律我們也能完成許多定理的證明，包括下面這些定理。</p>
<div class="theorem exercise" id="exr-and-or-commu">
<p><span class="theorem-title"><strong>习题 6</strong></span>  </p>
<strong>∧和∨的交換律：</strong> 證明<code>p ∧ q ↔︎ q ∧ p</code>和 證明<code>p ∨ q ↔︎ q ∨ p</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∧ q ↔ q ∧ p :=
  Iff.intro
    (
      fun h : p ∧ q =&gt;
        have hp : p := h.left
        have hq : q := h.right
        And.intro hq hp
    )
    (
      fun h : q ∧ p =&gt;
        have hq : q := h.left
        have hp : p := h.right
        And.intro hp hq
    )

example {p q : Prop} : p ∨ q ↔ q ∨ p :=
  Iff.intro
    (
      fun h : p ∨ q =&gt;
        Or.elim h
          (fun hp : p =&gt; Or.intro_right q hp)
          (fun hq : q =&gt; Or.intro_left p hq)
    )
    (
      fun h : q ∨ p =&gt;
        Or.elim h
          (fun hq : q =&gt; Or.intro_right p hq)
          (fun hp : p =&gt; Or.intro_left q hp)
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-and-or-associativity">
<p><span class="theorem-title"><strong>习题 7</strong></span>  </p>
<strong>∧和∨的結合律：</strong> 證明：<code>example : (p ∧ q) ∧ r ↔︎ p ∧ (q ∧ r)</code>和 <code>example : (p ∨ q) ∨ r ↔︎ p ∨ (q ∨ r)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q r : Prop} : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) :=
  Iff.intro
    (
      fun h : (p ∧ q) ∧ r =&gt;
        let hpq : p ∧ q := h.left
        let hr : r := h.right
        let hp : p := hpq.left
        let hq : q := hpq.right
        And.intro hp (And.intro hq hr)
    )
    (
      fun h : p ∧ (q ∧ r) =&gt;
        let hp : p := h.left
        let hqr : q ∧ r := h.right
        let hq : q := hqr.left
        let hr : r := hqr.right
        And.intro (And.intro hp hq) hr
    )

example {p q r: Prop} : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) :=
  Iff.intro
    (
      fun h : (p ∨ q) ∨ r =&gt;
        Or.elim h
          (fun hpq : p ∨ q =&gt;
            Or.elim hpq
              (fun hp : p =&gt; Or.intro_left (q ∨ r) hp)
              (fun hq : q =&gt; Or.intro_right p (Or.intro_left r hq))
          )
          (fun hr : r =&gt; Or.intro_right p (Or.intro_right q hr))

    )
    (
      fun h : p ∨ (q ∨ r) =&gt;
        Or.elim h
          (fun hp: p =&gt; Or.intro_left r (Or.intro_left q hp))
          (fun hqr: q ∨ r =&gt;
            Or.elim hqr
              (fun hq : q =&gt; Or.intro_left r (Or.intro_right p hq))
              (fun hr : r =&gt; Or.intro_right (p ∨ q) hr)
          )
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-and-or-distributivity">
<p><span class="theorem-title"><strong>习题 8</strong></span>  </p>
<strong>∧和∨的分配律：</strong>證明<code>p ∧ (q ∨ r) ↔︎ (p ∧ q) ∨ (p ∧ r)</code> 和<code>p ∨ (q ∧ r) ↔︎ (p ∨ q) ∧ (p ∨ r)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q r: Prop} : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro
    (
      fun h : p ∧ (q ∨ r) =&gt;
        let hp: p := h.left
        let hqr: q ∨ r := h.right
        Or.elim hqr
          (fun hq : q =&gt; Or.intro_left (p ∧ r) (And.intro hp hq))
          (fun hr : r =&gt; Or.intro_right (p ∧ q) (And.intro hp hr))
    )
    (
      fun h : (p ∧ q) ∨ (p ∧ r) =&gt;
        Or.elim h
          (fun hpq : p ∧ q =&gt;
            let hp : p := hpq.left
            let hq : q := hpq.right
            And.intro hp (Or.intro_left r hq)
          )
          (fun hpr : p ∧ r =&gt;
            let hp := hpr.left
            let hr := hpr.right
            And.intro hp (Or.intro_right q hr)
          )
    )
example {p q r : Prop} : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) :=
  Iff.intro
    (
      fun h : p ∨ (q ∧ r) =&gt;
        Or.elim h
          (fun hp : p =&gt; And.intro (Or.intro_left q hp) (Or.intro_left r hp))
          (fun hqr : q ∧ r =&gt;
            have hq :q := hqr.left
            have hr :r := hqr.right
            And.intro (Or.intro_right p hq) (Or.intro_right p hr)
          )
    )
    (
      fun h : (p ∨ q) ∧ (p ∨ r) =&gt;
        have hpq : p ∨ q := h.left
        have hpr : p ∨ r := h.right
        Or.elim hpq
          (fun hp: p =&gt; Or.intro_left (q ∧ r) hp)
          (fun hq: q =&gt; Or.elim hpr
            (fun hp: p =&gt; Or.intro_left (q ∧ r) hp)
            (fun hr: r =&gt;
              have hqr : q ∧ r := And.intro hq hr
              Or.intro_right p hqr
            )
          )
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-1">
<p><span class="theorem-title"><strong>习题 9</strong></span> 證明：<code>(p → (q → r)) ↔︎ (p ∧ q → r)</code></p>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q r : Prop} : (p → (q → r)) ↔ (p ∧ q → r) :=
  Iff.intro
    (
      fun hpqr : p → (q → r) =&gt;
        fun hpq : p ∧ q =&gt;
          have hp := hpq.left
          have hq := hpq.right
          hpqr hp hq
    )
    (
      fun hpqr : p ∧ q → r =&gt;
        fun hp : p =&gt;
          fun hq : q =&gt;
            have hpq := And.intro hp hq
            hpqr hpq
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-2">
<p><span class="theorem-title"><strong>习题 10</strong></span>  </p>
證明：<code>((p ∨ q) → r) ↔︎ (p → r) ∧ (q → r)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q r : Prop} : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) :=
  Iff.intro
    (
      fun hpqr : p ∨ q → r =&gt;
        And.intro
          (fun hp : p =&gt; hpqr (Or.intro_left q hp))
          (fun hq : q =&gt; hpqr (Or.intro_right p hq))
    )
    (
      fun hprqr : (p → r) ∧ (q → r) =&gt;
        have hpr : p → r := hprqr.left
        have hqr : q → r := hprqr.right
        fun hpq : p ∨ q =&gt;
          Or.elim hpq
            (fun hp : p =&gt; hpr hp)
            (fun hq : q =&gt; hqr hq)
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-3">
<p><span class="theorem-title"><strong>习题 11</strong></span>  </p>
證明：<code>¬(p ∨ q) ↔︎ ¬p ∧ ¬q</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : ¬(p ∨ q) ↔ ¬p ∧ ¬q :=
  Iff.intro
    (
      fun hnpq : ¬(p ∨ q) =&gt;
        And.intro
          (fun hp : p =&gt; hnpq (Or.intro_left q hp))
          (fun hq : q =&gt; hnpq (Or.intro_right p hq))
    )
    (
      fun hnpnq : ¬p ∧ ¬q =&gt;
        have hnp : ¬p := hnpnq.left
        have hnq : ¬q := hnpnq.right
        (
          fun hpq : p ∨ q =&gt; Or.elim hpq
            (fun hp : p =&gt; hnp hp)
            (fun hq : q =&gt; hnq hq)
        )
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-4">
<p><span class="theorem-title"><strong>习题 12</strong></span>  </p>
證明：<code>¬p ∨ ¬q → ¬(p ∧ q)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : ¬p ∨ ¬q → ¬(p ∧ q) :=
  fun hnpnq : ¬p ∨ ¬q =&gt;
    Or.elim hnpnq
      (fun hnp : ¬p =&gt; fun hpq : p ∧ q =&gt; hnp hpq.left)
      (fun hnq : ¬q =&gt; fun hpq : p ∧ q =&gt; hnq hpq.right)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-5">
<p><span class="theorem-title"><strong>习题 13</strong></span>  </p>
證明：<code>¬(p ∧ ¬p)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p : Prop} : ¬(p ∧ ¬p) :=
  fun hpnp : p ∧ ¬p =&gt;
    have hp : p := hpnp.left
    have hnp: ¬p := hpnp.right
    hnp hp</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-6">
<p><span class="theorem-title"><strong>习题 14</strong></span>  </p>
證明：<code>p ∧ ¬q → ¬(p → q)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∧ ¬q → ¬(p → q) :=
  fun hpnq : p ∧ ¬q =&gt;
    have hp : p := hpnq.left
    have hnq : ¬q := hpnq.right
    fun hpq : p → q =&gt;
      have hq : q := hpq hp
      hnq hq</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-7">
<p><span class="theorem-title"><strong>习题 15</strong></span>  </p>
證明：<code>¬p → (p → q)</code>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : ¬p → (p → q) :=
  fun hnp : ¬p =&gt;
    fun hp : p =&gt;
      False.elim (hnp hp)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-8">
<p><span class="theorem-title"><strong>习题 16</strong></span>  </p>
證明：(¬p ∨ q) → (p → q)
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : (¬p ∨ q) → (p → q) :=
  fun hnpq : ¬p ∨ q =&gt;
    fun hp : p =&gt;
      Or.elim hnpq
        (fun hnp : ¬p =&gt; False.elim (hnp hp))
        (fun hq : q =&gt; hq)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-9">
<p><span class="theorem-title"><strong>习题 17</strong></span>  </p>
<strong>同一律</strong>
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p : Prop} : p ∨ False ↔ p :=
  Iff.intro
    (
      fun hpf : p ∨ False =&gt;
      Or.elim hpf
        (fun hp : p =&gt; hp)
        (fun hf : False =&gt; False.elim hf)
    )
    (fun hp : p =&gt; Or.intro_left False hp)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-10">
<p><span class="theorem-title"><strong>习题 18</strong></span>  </p>
<strong>零律</strong> 證明：p ∧ False ↔︎ False
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p : Prop} : p ∧ False ↔ False :=
  Iff.intro
    (
      fun hpf : p ∧ False =&gt;
        have hf : False := hpf.right
        hf
    )
    fun hf : False =&gt;
      False.elim hf</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-11">
<p><span class="theorem-title"><strong>习题 19</strong></span>  </p>
<strong>假言易位</strong> 證明：(p → q) → (¬q → ¬p)
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : (p → q) → (¬q → ¬p) :=
  fun (hpq : p → q) (hnq : ¬q) =&gt;
    fun hp : p =&gt;
      hnq (hpq hp)</code></pre>
</details>
</div>
</section>
<section class="level2" data-number="2.6" id="練習二-經典邏輯">
<h2 class="anchored" data-anchor-id="練習二-經典邏輯" data-number="2.6"><span class="header-section-number">2.6</span> 練習二-經典邏輯</h2>
<p>下面的練習中，你可以使用排中律。</p>
<p>Lean中，排中律位於<code>Classical</code>命名空間下。</p>
<pre class="lean"><code>#check Classical.em</code></pre>
<p>我們可以臨時地使用Classical命名空間，而不幹擾其它代碼。方法為<code>open Classical in ...</code>，例如</p>
<pre class="lean"><code>open Classical in
example {p : Prop} : p ∨ ¬p := em p</code></pre>
<p>允許使用排中律，使得你可以分正反兩種情形分析問題。這對應<code>Classical</code>命名空間下的<code>byCases</code>定理：</p>
<pre class="lean"><code>#check Classical.byCases
-- Classical.byCases {p q : Prop} (hpq : p → q) (hnpq : ¬p → q) : q</code></pre>
<p>即如果分正反兩種情況討論，都有結論成立，說明結論成立。</p>
<div class="theorem exercise" id="exr-property-12">
<p><span class="theorem-title"><strong>习题 20</strong></span>  </p>
證明：(p → q ∨ r) → ((p → q) ∨ (p → r))
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q r : Prop} : (p → q ∨ r) → ((p → q) ∨ (p → r)) :=
  fun pqr : p → q ∨ r =&gt;
    Or.elim (em q)
    (
      fun hq : q =&gt;
        Or.intro_left (p → r) (fun _ : p =&gt; hq)
    )
    (
      fun hnq : ¬q =&gt;
        Or.intro_right (p → q)
        (
          fun hp : p =&gt;
            have qr : q ∨ r := pqr hp
            Or.elim qr
              (fun hq : q =&gt; False.elim (hnq hq))
              (fun hr : r =&gt; hr

        )
    )
  )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-13">
<p><span class="theorem-title"><strong>习题 21</strong></span>  </p>
證明：¬(p ∧ q) → ¬p ∨ ¬q
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : ¬(p ∧ q) → ¬p ∨ ¬q :=
  fun hnpq : ¬(p ∧ q) =&gt;
    byCases
      (
        fun hp : p =&gt;
          byCases
            (
              fun (hq : q) =&gt;
                have hpq : p ∧ q := And.intro hp hq
                absurd hpq hnpq
            )
            (fun (hnq : ¬q) =&gt; Or.intro_right (¬p) hnq)
      )
      (fun hnp : ¬p =&gt; Or.intro_left (¬q) hnp)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-14">
<p><span class="theorem-title"><strong>习题 22</strong></span>  </p>
證明：(p → q) → (¬p ∨ q)
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : (p → q) → (¬p ∨ q) :=
  fun hpq : (p → q) =&gt;
    byCases
      (
        fun hp : p =&gt;
          have hq : q := hpq hp
          Or.intro_right (¬p) hq
      )
      (
        fun hnp : ¬p =&gt; Or.intro_left q hnp
      )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-15">
<p><span class="theorem-title"><strong>习题 23</strong></span>  </p>
證明：(¬q → ¬p) → (p → q)
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : (¬q → ¬p) → (p → q) :=
  fun hnqnp : ¬q → ¬p =&gt;
    fun hp : p =&gt;
      Or.elim (em q)
        (fun hq : q =&gt; hq)
        (
          fun hnq : ¬q =&gt;
            have hnp : ¬p := hnqnp hnq
            False.elim (hnp hp)
        )</code></pre>
</details>
</div>
<div class="theorem example" id="exm-property-17">
<p><span class="theorem-title"><strong>例 4</strong></span>  </p>
證明：(((p → q) → p) → p)
<details>
<summary>
參考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : (((p → q) → p) → p) :=
  fun hpqp : (p → q) → p =&gt;
    byCases
      (fun hp : p =&gt; hp)
      (
        fun hnp : ¬p =&gt;
          have hpq : p → q := (fun hp : p =&gt; False.elim (hnp hp))
          have hp : p := hpqp hpq
          False.elim (hnp hp)
      )</code></pre>
</details>
</div>
</section>
</section>
<section class="level1" data-number="3" id="總結">

<p>也許現在告訴你有點太遲，但其實本章的所有例子和例題都可以由<code>tauto</code>策略實現一句話完成自動證明。如下所示，</p>
<pre class="lean"><code>-- example {p q r: Prop} : (p → (q → r)) ↔ (p ∧ q → r) := by tauto
-- 注意：使用tauto需要import Mathlib.Tactic.Tauto</code></pre>
<p><code>tauto</code>策略可以證明各種各樣的命題邏輯。我們將會在後續的文章中看到更多的證明策略，以及如何使用它們來證明更加複雜的命題。</p>
<p>至此，本章介紹了Lean中命題邏輯的基礎知識，希望你已經理解在Lean中如何引用定理，顯式地構造一個命題的證明，或者使用<code>tauto</code>策略自動完成命題邏輯的證明。</p>
</section>
</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
</div>
    </div>
    <div class="post_list">
        <span>By </span>
        <a href="https://zhimi.vercel.app/">@執迷</a>
        <span> in </span>
        <span class="post_category"><a href="https://zhimi.vercel.app/" rel="bookmark" title="Permalink to Lean 4">[ Lean 4 ]</a></span>
        <span class="post_date">2025-01-12</span>
        <div><span>Tags : </span>
            
            
            <span><a href="https://zhimi.vercel.app/">#Lean, </a></span>
            
            <span><a href="https://zhimi.vercel.app/">#自動證明器, </a></span>
            
            <span><a href="https://zhimi.vercel.app/">#數學, </a></span>
            
            <span><a href="https://zhimi.vercel.app/">#命題邏輯, </a></span>
            
            
        </div>

        <div class="entry-social-container" style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
            
            
            <div class="entry-social" style="text-align: center;">
                <span class="social-text">分享本文</span><br>
                <div class="social-icons" style="display: flex; gap: 10px; justify-content: center;">
                    <span class="twitter"><a target="_blank" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;" title="Twitter" href="https://twitter.com/share?url=https://zhimi.vercel.app/./lean_logic_20250111.html&text=Lean语言数学之旅——命題邏輯&via="><img src="https://zhimi.vercel.app/theme/images/icons/twitter-s.png"></a></span>
                    <a target="_blank" title="Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https://zhimi.vercel.app/./lean_logic_20250111.html&title=Lean语言数学之旅——命題邏輯" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="https://zhimi.vercel.app/theme/images/icons/linkedin-s.png"></a>
                    <span class="mail"><a href="mailto:?subject=Lean语言数学之旅——命題邏輯&amp;body=Viens découvrir un article à propos de [Lean语言数学之旅——命題邏輯] sur le site de 執迷. https://zhimi.vercel.app/./lean_logic_20250111.html" title="Share by Email" target="_blank"><img src="https://zhimi.vercel.app/theme/images/icons/mail-s.png"></a></span>
                </div>
            </div>
        </div>
        </div>
    </div>
    

</section>

<!-- Quarto Clipboard -->
<script type="text/javascript">
    var clipboard = new ClipboardJS(
        '.code-copy-button',
        {
            target: function(trigger) {
                console.log("Copy texts. ", trigger);
                return trigger.previousElementSibling;
            }
        }
    );    
    clipboard.on('success', function(e) {
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        e.clearSelection();
        alert('Copied!');
    });
    console.log("ClipboardJS loaded.");
</script>

  </article>

  <!-- Footer -->
  <footer>
    <p>
      Blog powered by <a href="http://getpelican.com/">Pelican</a>, 
      which takes great advantage of <a href="http://python.org">Python</a>.
      Theme <a href="https://github.com/parbhat/pelican-blue">Pelican-Blue</a> by <a href="https://parbhatpuri.com/">@parbhat</a>.
    </p>
    
      
      <span id="busuanzi_container_site_pv">總訪問量<span id="busuanzi_value_site_pv"></span></span>
      <span id="busuanzi_container_site_uv">
        訪客數<span id="busuanzi_value_site_uv"></span>
      </span>
      
    
  </footer>
</body>
</html>