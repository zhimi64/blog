<!doctype html>
<html lang="" itemscope itemtype="http://schema.org/Person">
<head>

  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G3N739QVFZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-G3N739QVFZ');
  </script>
  

  
  <script>
    window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
  </script>
  <script defer src="./_vercel/insights/script.js"></script>
  

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  
  

<!-- Quarto -->
<link href="./theme/css/quarto/quarto.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>
<script src="./theme/scripts/quarto/quarto.js"></script>


  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>相機模型和相機標定</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="執迷">

  <link rel="shortcut icon" href="">

  <!-- schema.org -->
  <meta itemprop="name" content="執迷的博客">
  <meta itemprop="image" content="">
  <meta itemprop="description" content="">

  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
  <!-- Style Meta Data -->
  <link rel="stylesheet" href="./theme/css/style.css" type="text/css" />
  <link rel="stylesheet" href="./theme/css/pygments.css" type="text/css" />

  <!-- Feed Meta Data -->
  
  

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="">
  
<meta name="twitter:creator" content="">
<meta name="twitter:url" content="././calibration_20220222.html">
<meta name="twitter:title" content="執迷的博客 ~ 相機模型和相機標定">
<meta name="twitter:description" content="">

<!-- Facebook Meta Data -->
<meta property="og:title" content="執迷的博客 ~ 相機模型和相機標定" />
<meta property="og:description" content="" />
<meta property="og:image" content="" />


<!-- MathJax -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>




</head>

<body>
  <!-- Sidebar -->
  <aside>
    <!--<center><a href="."><img id="avatar" src=""></a></center>-->
    <h1>執迷的博客</h1>
    
      <p>做一個有趣的人！</p>
    
    <br>

    

    <nav class="nav">
      <ul class="list-bare">
      
        
          <li><a class="nav__link" href="./index.html">Blog</a></li>
        
         
        
          <li><a class="nav__link" href="././about.html">About</a></li>
        
         
      </ul>
    </nav>

    <p class="social">
      
      
      
    </p>

    <!--
    
    -->
  </aside>

  <!-- Content -->
  <article>
    
<section id="content">
    <h2 class="post_title post_detail"><a href="././calibration_20220222.html" rel="bookmark" title="Permalink to 相機模型和相機標定">相機模型和相機標定</a></h2>
    
    <p>
        <span id="busuanzi_container_page_pv">
            本文瀏覽次數<span id="busuanzi_value_page_pv"></span>
        </span>
    </p>
    
    <div class="entry-content blog-post">
        <div>
<div class="page-columns page-rows-contents page-layout-article" id="quarto-content">
<div class="sidebar margin-sidebar" id="quarto-margin-sidebar">
<nav class="toc-active" id="TOC" role="doc-toc">
<h2 id="toc-title">目录</h2>
<ul>
<li><a class="nav-link active" data-scroll-target="#什麽是相機標定" href="#什麽是相機標定" id="toc-什麽是相機標定"><span class="toc-section-number">1</span>  什麽是相機標定</a></li>
<li><a class="nav-link" data-scroll-target="#相機坐標系和世界坐標系" href="#相機坐標系和世界坐標系" id="toc-相機坐標系和世界坐標系"><span class="toc-section-number">2</span>  相機坐標系和世界坐標系</a></li>
<li><a class="nav-link" data-scroll-target="#針孔相機模型" href="#針孔相機模型" id="toc-針孔相機模型"><span class="toc-section-number">3</span>  針孔相機模型</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#透視投影" href="#透視投影" id="toc-透視投影"><span class="toc-section-number">3.1</span>  透視投影</a></li>
<li><a class="nav-link" data-scroll-target="#鏡頭畸變" href="#鏡頭畸變" id="toc-鏡頭畸變"><span class="toc-section-number">3.2</span>  鏡頭畸變</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#標定" href="#標定" id="toc-標定"><span class="toc-section-number">4</span>  標定</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#標定工具" href="#標定工具" id="toc-標定工具"><span class="toc-section-number">4.1</span>  標定工具</a></li>
<li><a class="nav-link" data-scroll-target="#標定流程" href="#標定流程" id="toc-標定流程"><span class="toc-section-number">4.2</span>  標定流程</a></li>
<li><a class="nav-link" data-scroll-target="#內外參的閉式解" href="#內外參的閉式解" id="toc-內外參的閉式解"><span class="toc-section-number">4.3</span>  內外參的閉式解</a></li>
<li><a class="nav-link" data-scroll-target="#求相機的畸變係數" href="#求相機的畸變係數" id="toc-求相機的畸變係數"><span class="toc-section-number">4.4</span>  求相機的畸變係數</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#思考題" href="#思考題" id="toc-思考題"><span class="toc-section-number">5</span>  思考題</a></li>
<li><a class="nav-link" data-scroll-target="#參考文獻" href="#參考文獻" id="toc-參考文獻"><span class="toc-section-number">6</span>  參考文獻</a></li>
<li><a class="nav-link" data-scroll-target="#附錄" href="#附錄" id="toc-附錄"><span class="toc-section-number">7</span>  附錄</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#標定算法的python實現" href="#標定算法的python實現" id="toc-標定算法的python實現"><span class="toc-section-number">7.1</span>  標定算法的Python實現</a></li>
<li><a class="nav-link" data-scroll-target="#版權信息" href="#版權信息" id="toc-版權信息"><span class="toc-section-number">7.2</span>  版權信息</a></li>
</ul></li>
</ul>
</nav>
</div>
<main class="content" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header">
<div class="quarto-title">

</div>
<div class="quarto-title-meta">
<div>
<div class="quarto-title-meta-heading">发布日期</div>
<div class="quarto-title-meta-contents">
<p class="date">2022年2月22日</p>
</div>
</div>
</div>
</header>
<section class="level2" data-number="1" id="什麽是相機標定">
<h2 class="anchored" data-anchor-id="什麽是相機標定" data-number="1"><span class="header-section-number">1</span> 什麽是相機標定</h2>
<p>影響相機成像過程的因素有很多。一束光先是從光源出發，落在物體表面。而後它又經過物體表面的反射，進入相機，穿過鏡頭和光圈，最後落在感光芯片上。這個過程中，物體的形狀、方位、焦距、光圈數、感光芯片的大小、感光單元的分佈間距……許許多多參數會對最終的成像產生影響。</p>
<p><strong>相機標定是求解相機參數的過程</strong>。相機的參數又分為內參和外參。 <strong>内參</strong>包括相機的焦距、感光單元的間距、鏡頭畸變係數等。<strong>外參</strong>是相機相對於其它外部事物的位姿。一旦外參和内參是確定的，那我們就能確切地知道外部世界的某一個點發出的光綫會落在圖像的哪個位置。因此，許多任務，例如雙目視覺、增強現實、立體匹配、單目3D目標檢測……都需要使用準確的相機內外參。</p>
<p>內外參常常是無法直接精確測得的。我們無法直接用尺子測量鏡頭到感光芯片的距離，更無法用普通工具測量芯片上感光單元之間的間距（這是微米級別的尺寸），而鏡頭的畸變模型還帶來更多更複雜的因素。要如何精確地得出這些數值呢？</p>
<p>首先，我們要建立相機的數學模型。 本文介紹常見的針孔相機模型。它用小孔成像來近似相機的成像過程。理解針孔相機模型，有助於學習其它相機模型，例如魚眼相機模型和線陣相機模型。</p>
<p>相機模型建立後，我們用相機拍攝特定標定物，根據標定物的參數及成像效果，可以間接推斷出相機的各項參數。</p>
</section>
<section class="level2" data-number="2" id="相機坐標系和世界坐標系">
<h2 class="anchored" data-anchor-id="相機坐標系和世界坐標系" data-number="2"><span class="header-section-number">2</span> 相機坐標系和世界坐標系</h2>
<div class="quarto-figure quarto-figure-center anchored" id="fig-cam_coord_system">
<figure class="figure">
<figure class="figure">
<img class="img-fluid figure-img" src="calibration_20220222\imgs\cam_model\coord_system.png" title="相机坐标系"/>
</figure>
<p></p><figcaption class="figure-caption">图 1: 相机坐标系.png</figcaption><p></p>
</figure>
</div>
<p>常見的<strong>相機坐標系</strong>如<a href="#fig-cam_coord_system">圖 1</a>所示。相機鏡頭朝前時，x軸朝右，y軸朝下，z軸朝前。</p>
<p>當然，你也可以採用不一樣的坐標系設定。坐標系的定義不同不會影響相機模型和參數標定過程的數學本質，標定的方法也是一樣的。但採取“另類”的設計有時會帶來一些不必要的麻煩。</p>
<p>與相機坐標系相對的是<strong>世界坐標系</strong>。世界坐标系的定义根据问题的不同而不同。它可以定义在某张标定板上，也可以定义在某个传感器上。某点世界坐标系与相机坐标系上的坐标可以通过刚性变换来转换。假设<span class="math inline">\(\mathbf p_w\)</span>是世界坐标系下的坐标，<span class="math inline">\(\mathbf p_c\)</span>是相机坐标系下的坐标，那么存在选择矩阵<span class="math inline">\(\mathbf R\)</span>和平移向量<span class="math inline">\(\mathbf t\)</span>使得 <span class="math display">\[
\mathbf p_c= \mathbf R\mathbf p_w + \mathbf t
\]</span></p>
<p>这里的向量<span class="math inline">\(\mathbf t=(t_x, t_y, t_z)^T\)</span>。旋转矩阵<span class="math inline">\(\mathbf R\)</span>是三行三列的方阵。</p>
<p>解释一下旋轉矩陣的計算。假設旋轉的過程是繞著z軸旋轉角度<span class="math inline">\(\gamma\)</span>，再繞y軸旋轉角度<span class="math inline">\(\beta\)</span>，再繞x軸旋轉角度<span class="math inline">\(\alpha\)</span>，那麼旋轉矩陣 <span class="math display">\[
\mathbf R(\alpha, \beta, \gamma) =
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \alpha &amp; -\sin \alpha \\
0 &amp; \sin \alpha &amp; \cos \alpha
\end{array}\right)
\left(\begin{array}{ccc}
\cos \beta &amp; 0 &amp; \sin \beta \\
0 &amp; 1 &amp; 0 \\
-\sin \beta &amp; 0 &amp; \cos \beta
\end{array}\right)
\left(\begin{array}{ccc}
\cos \gamma &amp; -\sin \gamma &amp; 0\\
\sin \gamma &amp; \cos\gamma &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right).
\]</span></p>
<p>所以，旋轉矩陣可以由3個旋轉角度決定。這三個角度被稱為歐拉角。</p>
<div class="tips">
<p>需要注意，旋轉角度、旋轉軸的順序不是唯一的。比如，也可以先繞<span class="math inline">\(x\)</span>軸旋轉一個角度，再繞<span class="math inline">\(z\)</span>軸旋轉，再繞<span class="math inline">\(x\)</span>軸旋轉。在具體的問題中，要注意歐拉角的定義。</p>
</div>
<p>總而言之，六元組<span class="math inline">\((t_x, t_y, t_z, \alpha, \beta, \gamma)\)</span>決定了參考坐標系，它們構成相機的<strong>外參</strong>。</p>
</section>
<section class="level2" data-number="3" id="針孔相機模型">
<h2 class="anchored" data-anchor-id="針孔相機模型" data-number="3"><span class="header-section-number">3</span> 針孔相機模型</h2>
<section class="level3" data-number="3.1" id="透視投影">
<h3 class="anchored" data-anchor-id="透視投影" data-number="3.1"><span class="header-section-number">3.1</span> 透視投影</h3>
<p>接下來介紹針孔相機模型。</p>
<div class="quarto-figure quarto-figure-center anchored" id="fig-pinhole_model">
<figure class="figure">
<figure class="figure">
<img class="img-fluid figure-img" src="calibration_20220222\imgs\pinhole_imaging\pinhole_cam.png" title="針孔相機模型"/>
</figure>
<p></p><figcaption class="figure-caption">图 2: 針孔相機模型</figcaption><p></p>
</figure>
</div>
<p>我們忽略光線所具有的“波”的性質。我們僅需知道，“光是沿直線傳播的”。那麼，如<a href="#fig-pinhole_model">圖 2</a>所示物體上發出的光只能經過小孔落在成像平面上。經過小孔，上方的光綫落在下面，下方的光綫落在上面。小孔成像所成的是倒立的實像。</p>
<p>雖然小孔成像在物理上是這樣解釋的，但是，計算機從業者卻常用另外的圖示來表達這一過程。</p>
<div class="quarto-figure quarto-figure-center anchored" id="fig-pinhole_model_simplified">
<figure class="figure">
<figure class="figure">
<img class="img-fluid figure-img" src="calibration_20220222\imgs\pinhole_imaging\pinhole_cam_2.png" title="小孔成像的另一種表示法"/>
</figure>
<p></p><figcaption class="figure-caption">图 3: 小孔成像的另一種表示法</figcaption><p></p>
</figure>
</div>
<p>在<a href="#fig-pinhole_model_simplified">圖 3</a>中，你可以看到對象物體和所成像都畫在小孔（又被稱爲主点）的同一側，並且直接繪製正像。你可能會問，這種事在物理上怎麽可能發生呢？</p>
<p>這在物理上當然是不合理的。之所以計算機的從業者這樣繪圖，只是因爲方便。這種畫法因爲能節省作圖空間，且避免了麻煩的坐標系旋轉而十分常見。通過避免坐標旋轉，可以簡化數學運算。</p>
<p>小孔成像的原理可以很容易用數學公式描述。假設相機坐標系中有一點<span class="math inline">\(\mathbf p_c=(x_c, y_c, z_c)^T\)</span>，這個點發出的光綫經過了小孔，那麽可以通過如下公式求得成像點的位置：</p>
<p><span class="math display">\[ x = \frac{x_c f}{z_c},  y = \frac{y_c f}{z_c}.\]</span></p>
<p>其中<span class="math inline">\(f\)</span>是小孔到成像平面的距離。 <a href="#fig-projection">圖 4</a>或許有助於你理解該公式。從圖中我們可以看到，成像點總是位於<span class="math inline">\(z = f\)</span>的平面上，並且與原點<span class="math inline">\(\mathbf o\)</span>和被成像點<span class="math inline">\(\mathbf p_c\)</span>共線。因此，我們只須求出直線<span class="math inline">\(\mathbf o \mathbf p_c\)</span>與成像平面的角點，也就得到了成像點的坐標。</p>
<div class="quarto-figure quarto-figure-center anchored" id="fig-projection">
<figure class="figure">
<figure class="figure">
<img class="img-fluid figure-img" src="calibration_20220222\imgs\proj_transform\proj_transform.svg" title="投影变换的几何图示"/>
</figure>
<p></p><figcaption class="figure-caption">图 4: 投影变换的几何图示</figcaption><p></p>
</figure>
</div>
<p>在計算機視覺應用中，圖像會被離散化為以像素為單位的矩陣。要將<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>坐標同像素的行列對應起來，還需要在成像公式中加入縮放係數和偏移量：</p>
<p><span class="math display">\[
c = \frac{x_c f}{z_c s_x} + c_x,  r = \frac{y_c f}{z_c s_y} + c_y.
\]</span></p>
<p>這裏<span class="math inline">\(s_x\)</span>和<span class="math inline">\(s_y\)</span>就是感光芯片陣列在橫向和縱向上的間距。 這樣，通過這個公式，我們就知道點<span class="math inline">\(\mathbf p_c\)</span>落在圖像<span class="math inline">\(r\)</span>行<span class="math inline">\(c\)</span>列的位置。</p>
<p>令<span class="math inline">\(f_x = f / s_x\)</span>，以及<span class="math inline">\(f_y = f / s_y\)</span>，則有</p>
<p><span class="math display">\[ c = \frac{x_c f_x}{z_c} + c_x,  r = \frac{y_c f_y}{z_c} + c_y.\]</span></p>
<p>對於市面上的相機，一般都有<span class="math inline">\(s_x=s_y\)</span>，於是<span class="math inline">\(f_x = f_y\)</span>。一種<span class="math inline">\(s_x\neq s_y\)</span>的特殊情況（見文獻<span class="citation" data-cites="carsten_steger_pdf_nodate"><sup>[<a href="#ref-carsten_steger_pdf_nodate" role="doc-biblioref">1</a>]</sup></span> 71頁的2.3.1節），是採集卡的時鐘頻率與攝像機時鐘頻率不一致從而導致像素橫縱比率改變。這種情形比較少見。</p>
<!-- （既然一般有$f_x=f_y$，許多文章將$f_x$和$f_y$記爲$f$。） -->
<!-- 注意這種定義下的$f$不代表成像平面到主点的距離。 -->
<p>這兩個公式可以轉寫為方便的矩陣乘法的形式： <span class="math display">\[
(c',r', z_c)^T =
\left(
\begin{array}{ccc}
f_x &amp; 0 &amp; c_x\\
0 &amp; f_y &amp; c_y\\
0 &amp; 0 &amp; 1
\end{array}
\right)
\left(
\begin{array}{c}
x_c\\ y_c\\ z_c \\
\end{array}
\right) = \mathbf P
\left(
\begin{array}{c}
x_c\\ y_c\\ z_c \\
\end{array}
\right)
\]</span> 其中<span class="math inline">\(\mathbf P\)</span>被稱為投影矩陣，<span class="math inline">\(c'\)</span>、<span class="math inline">\(r'\)</span>是橫縱坐標的分子，而<span class="math inline">\(z_c\)</span>是它們公共的分母： <span class="math display">\[
c = \frac{c'}{z_c}
\]</span></p>
<p><span class="math display">\[
r = \frac{r'}{z_c}
\]</span></p>
<p>結合內參和外參，則成像點的計算公式是： <span id="eq-projection_matrix_full"><span class="math display">\[
s\left(
\begin{array}{c}
c\\r\\1
\end{array}
\right) =
\mathbf P(\mathbf R\mathbf p_w +  \mathbf T)
=
\mathbf P (\mathbf r_1, \mathbf r_2, \mathbf r_3, \mathbf t)
\left(
\begin{array}{c}
x_w\\ y_w\\ z_w\\ 1
\end{array}
\right)
\tag{1}\]</span></span> 其中<span class="math inline">\(r_i\)</span>是矩陣<span class="math inline">\(\mathbf R\)</span>的第i列。</p>
</section>
<section class="level3" data-number="3.2" id="鏡頭畸變">
<h3 class="anchored" data-anchor-id="鏡頭畸變" data-number="3.2"><span class="header-section-number">3.2</span> 鏡頭畸變</h3>
<p>對於大多數鏡頭而言，它們的畸變都可以被近似為徑向畸變。</p>
<div class="quarto-figure quarto-figure-center anchored" id="fig-barrel_distortion">
<figure class="figure">
<figure class="figure">
<img class="img-fluid figure-img" src="calibration_20220222\imgs\barrel_distortion\img.png" title="這張圖帶有輕微的桶形畸變"/>
</figure>
<p></p><figcaption class="figure-caption">图 5: 桶形畸變</figcaption><p></p>
</figure>
</div>
<p>徑向畸變： <span class="math display">\[
\left(
\begin{array}{c}
u' \\
v'
\end{array}
\right)
= \frac{2}{1 + \sqrt{1 - 4 \kappa (u^2 + v^2)}}
\left(
\begin{array}{c}
u \\ v
\end{array}
\right)
\]</span></p>
<div class="tips">
<p>這是Halcon庫採用的畸變公式。不同的程序庫或文獻可能使用不同的畸變公式。例如，OpenCV有一套更複雜的<a href="https://docs.opencv.org/3.4.2/da/d54/group__imgproc__transform.html#ga7dfb72c9cf9780a347fbe3d1c47e5d5a">畸變描述方式</a>。 它們的共同特征是用非線性函數來表示畸變。</p>
<p>昂貴的工業相機可以使用簡單的畸變模型，而便宜的網絡相機可能需要使用複雜的畸變模型。</p>
</div>
</section>
</section>
<section class="level2" data-number="4" id="標定">
<h2 class="anchored" data-anchor-id="標定" data-number="4"><span class="header-section-number">4</span> 標定</h2>
<p>標定就是求解相機內外參的過程。對於針孔相機模型，我們有內參數<span class="math inline">\((\kappa, f_x, f_y, c_x, c_y)\)</span>，外參數<span class="math inline">\((\alpha, \beta, \gamma, t_x, t_y, t_z)\)</span>. 標定時我們需要拍攝多張標定板的圖像。雖然相機的內參是固定的，但每次拍攝，標定板的位置都不一樣，所以<strong>每次拍攝都產生一組待解的外參</strong>。總的待解參數的量是<span class="math inline">\(\text{內參數量}+\text{外參數量}\times\text{圖片數量}\)</span>.</p>
<section class="level3" data-number="4.1" id="標定工具">
<h3 class="anchored" data-anchor-id="標定工具" data-number="4.1"><span class="header-section-number">4.1</span> 標定工具</h3>
<p>我們使用張氏標定法來完成標定。需要使用標定板這一工具</p>
<div class="quarto-figure quarto-figure-center anchored" id="fig-calibration_board">
<figure class="figure">
<figure class="figure">
<img class="img-fluid figure-img" src="calibration_20220222\imgs\man_with_calibration_board\img.png" title="手持3x4標定板的人"/>
</figure>
<p></p><figcaption class="figure-caption">图 6: 手持3x4標定板的人</figcaption><p></p>
</figure>
</div>
<p>標定板是黑白相間的方格子，這種被稱為“棋盤格標定板”。材質有A4紙的、鋁合金的，也有玻璃制的。材質決定了標定板的精度，也影響標定精度。如果你的應用場景對標定精度的要求很高，你可能需要選擇一種昂貴的材料，而不是簡單地用A4紙打印一張標定板。</p>
<p>我們檢測的是棋盤格標定板上的角點。角點的個數最好是奇數個x偶數個。圖案最好不是旋轉對稱的。</p>
<p>也有圓形圖案的標定板。但我更喜歡棋盤格圖案，因為<strong>圓形的投影中心不一定是圓形的中心</strong>，這會給檢測帶來麻煩。另外，角點檢測也比邊緣檢測準確，後者容易受光照影響而發生偏移。橢圓擬合的準確性依賴於邊緣檢測，因此拍照時必須控制好光照。</p>
</section>
<section class="level3" data-number="4.2" id="標定流程">
<h3 class="anchored" data-anchor-id="標定流程" data-number="4.2"><span class="header-section-number">4.2</span> 標定流程</h3>
<p>標定時，我們從多個方位拍攝標定板，產生若干圖像（例如15張，30張）。</p>
<p>拍好照片後，可以使用廣為人知、影響深遠的張氏標定法<span class="citation" data-cites="zhang_flexible_2000"><sup>[<a href="#ref-zhang_flexible_2000" role="doc-biblioref">2</a>]</sup></span>求解相機內外參。</p>
</section>
<section class="level3" data-number="4.3" id="內外參的閉式解">
<h3 class="anchored" data-anchor-id="內外參的閉式解" data-number="4.3"><span class="header-section-number">4.3</span> 內外參的閉式解</h3>
<p>先從簡單的情況著手——假設不存在畸變，此時問題有閉式解。</p>
<p>我們需要做的只是求解線性變換：</p>
<p><span class="math display">\[
s\left(
\begin{array}{c}
c\\r\\1
\end{array}
\right) =
\mathbf P(\mathbf R\mathbf p_w + \mathbf T)
=
P (\mathbf r_1, \mathbf r_2, \mathbf r_3, \mathbf t)
\left(
\begin{array}{c}
x_w\\ y_w\\ z_w\\ 1
\end{array}
\right)
\]</span></p>
<p>注意標定板是平面，所以<span class="math inline">\(z_w = 0\)</span>，上式化簡為</p>
<p><span class="math display">\[
s\left(
\begin{array}{c}
c\\r\\1
\end{array}
\right) =
\mathbf P(\mathbf R\mathbf p_w + \mathbf T)
=
\mathbf P (\mathbf r_1, \mathbf r_2, \mathbf t)
\left(
\begin{array}{c}
x_w\\ y_w\\ 1
\end{array}
\right)
\]</span></p>
<p>令<span class="math inline">\(\mathbf H = \mathbf P(\mathbf r_1, \mathbf r_2 , \mathbf t)\)</span>，上式可以寫為 <span class="math display">\[\tilde{\mathbf m} = \mathbf H \tilde{\mathbf M}\]</span> 其中<span class="math inline">\(\tilde{\mathbf m}\)</span>表示點在圖像上的投影的齊次坐標，<span class="math inline">\(\tilde{\mathbf M}\)</span>表示點在標定板上的坐標。 只要標定板上的點足夠多，那麼就可以用最小二乘法求得<span class="math inline">\(\mathbf H\)</span>.</p>
<p>又令<span class="math inline">\(\mathbf H = \left[\mathbf h_1, \mathbf h_2, \mathbf h_3\right]\)</span>，其中<span class="math inline">\(\mathbf h_i\)</span>是其第i列的三維向量。</p>
<p>由於R是單位正交陣，所以<span class="math inline">\(r_1\)</span>, <span class="math inline">\(r_2\)</span>是相互正交的單位向量，故而 <span id="eq-constraint1"><span class="math display">\[
\mathbf h_1^T \mathbf P^{-T} \mathbf P^{-1} \mathbf h_2 = 0
\tag{2}\]</span></span></p>
<p><span id="eq-constraint2"><span class="math display">\[
\mathbf h_1^T \mathbf P^{-T} \mathbf P^{-1} \mathbf h_1 = \mathbf h_2^T \mathbf P^{-T} \mathbf P^{-1} \mathbf h_2
\tag{3}\]</span></span></p>
<p>再令 <span class="math display">\[\mathbf B = \lambda \mathbf P^{-T} \mathbf P^{-1} \equiv \left( \begin{array}{ccc}
B_{11} &amp; B_{12} &amp; B_{13} \\
B_{12} &amp; B_{22} &amp; B_{23} \\
B_{13} &amp; B_{23} &amp; B_{33} \\
\end{array}\right)
\]</span> 其中<span class="math inline">\(\lambda\)</span>是一個任意的縮放係數。<span class="math inline">\(\mathbf B\)</span>是一個對稱矩陣。注意到由於本文對<span class="math inline">\(\mathbf P\)</span>的定義，<span class="math inline">\(B_{12}=0\)</span>. 所以<span class="math inline">\(\mathbf B\)</span>可以由六維向量<span class="math inline">\(\mathbf b = \left(B_{11}, B_{22}, B_{13}, B_{23}, B_{33}\right)^T\)</span>決定。</p>
<p>設<span class="math inline">\(\mathbf h_i = (h_{i1}, h_{i2}, h_{i3})^T\)</span>是<span class="math inline">\(\mathbf H\)</span>的第i列，那麼， <span class="math display">\[
\mathbf h_i^T \mathbf{B} \mathbf h_j = \mathbf v_{ij}^T \mathbf b,
\]</span> 其中 <span class="math display">\[
\mathbf v_{ij} = (h_{i1}h_{j1}, h_{i2}h_{j2}, h_{i3}h_{j1} + h_{i1} h _{j3}, h_{i3}h_{j2} + h_{i2}h_{j3}, h_{i3}h_{j3})
\]</span> 於是，<a href="#eq-constraint1">公式 2</a>、<a href="#eq-constraint2">公式 3</a>中的約束可以轉化為如下線性約束： <span class="math display">\[
\left(\begin{array}{c}
\mathbf v_{12}^T \\ (\mathbf v_{11} - \mathbf v_{12}) ^T
\end{array}
\right) \mathbf b = \mathbf 0
\]</span></p>
<p>假設我們拍攝了n張圖片，那麼將n個這樣的公式堆疊起來，就得到 <span class="math display">\[
\mathbf V \mathbf b = \mathbf 0
\]</span></p>
<p><span class="math inline">\(\mathbf V\)</span>是由<span class="math inline">\(\mathbf H\)</span>決定的，可以通過單張圖像求得，而<span class="math inline">\(\mathbf b\)</span>是由相機的內參決定的。我們要求得<span class="math inline">\(\mathbf b\)</span>。可以用著名的線性最小二乘法求解這個問題。只要數據點足夠多，則這個問題有閉式解。</p>
<p>一旦<span class="math inline">\(\mathbf b\)</span>得解，那麼我們可以恢復出相機的內參。可以證明 <span class="math display">\[
\begin{aligned}
c_y &amp;= - B_{11} B_{23} / (B_{11}B_{22})           \\
\lambda &amp;= B_{33} - (B_{13}^2 + c_y (- B_{11}B_{23})) / B_{11} \\
f_x &amp;= \sqrt{\lambda / B_{11}}  \\
f_y &amp;= \sqrt{\lambda B_{11} / (B_{11}B_{22})}                     \\
c_x &amp;= - B_{13} \alpha^2 / \lambda
\end{aligned}
\]</span></p>
<p>接下來，各張圖像的外參也可依次求得。 <span class="math display">\[
\mathbf r_1 = \lambda \mathbf A^{-1}\mathbf h_1, \mathbf r_2 = \lambda \mathbf A^{-1} \mathbf h_2
, \mathbf r_3 = \mathbf r_1 \times \mathbf r_2, \mathbf t = \lambda \mathbf A ^{-1} \mathbf h_3\]</span> 注意，這裡求解出的旋轉矩陣可能不是單位正交矩陣，需要用SVD分解的方法將其轉變為單位正交陣。</p>
<p>總結一下本小節的內容：假設相機沒有畸變，那麼可以先求得每張圖像對應的單應性變換矩陣<span class="math inline">\(\mathbf H\)</span>，然後，可以依次求得相機內外參。這種情況下，內外參數的解是閉式解。</p>
</section>
<section class="level3" data-number="4.4" id="求相機的畸變係數">
<h3 class="anchored" data-anchor-id="求相機的畸變係數" data-number="4.4"><span class="header-section-number">4.4</span> 求相機的畸變係數</h3>
<p>上一節，我們求解了相機的內外參。但這種解法存在幾個問題：</p>
<ol type="1">
<li>我們假設相機沒有畸變；</li>
<li>我們通過最小二乘來求解問題。但這裡應用的最小二乘所最小化的距離度量<strong>沒有實際的物理意義</strong>。</li>
</ol>
<p>所以，張氏標定法用上一節所介紹的方法求得的解作為初始解，用LM算法繼續優化該解。目標函數為： <span class="math display">\[\sum_{i} \sum_{j} \left\| m_{ij} - \phi(\mathbf P, \mathbf R_i \mathbf t_i, \mathbf M_j)\right\| ^2\]</span> 其中<span class="math inline">\(\phi\)</span>是考慮了相機畸變的非線性投影函數，解決了問題 1. 新的目標函數旨在最小化投影誤差，是具有實際物理意義的，解決了問題2.</p>
</section>
</section>
<section class="level2" data-number="5" id="思考題">
<h2 class="anchored" data-anchor-id="思考題" data-number="5"><span class="header-section-number">5</span> 思考題</h2>
<p><strong>一張標定板最少應該有多少個點？至少應當拍攝多少張標定板圖像？</strong></p>
<p>標定板的點數至少應該使得<span class="math inline">\(H\)</span>可解。而三維方陣<span class="math inline">\(H\)</span>作為單應性變換，有8個自由度。 標定板的每個點都可以提供兩行投影方程，因此如果有四個點，則理論上<span class="math inline">\(H\)</span>可解。因為<span class="math inline">\(\mathbf V\)</span>是<span class="math inline">\(2n\)</span>行的矩陣，而內參（不包括畸變係數，分別是<span class="math inline">\(f_x\)</span>、<span class="math inline">\(f_y\)</span>、<span class="math inline">\(c_x\)</span>、<span class="math inline">\(c_y\)</span>）有4個，故而理論上圖片張數<span class="math inline">\(n\geq 2\)</span>時問題可解。</p>
<p>當然，實際上為了獲得較好的精度，我們會適當取多一些點，多幾張圖片。實踐中，如果點數、圖片數不夠多，解的精度是很差的。</p>
</section>
<div class="default" id="quarto-appendix"><section class="level2 appendix" data-number="6" id="參考文獻"><h2 class="quarto-appendix-heading"><span class="header-section-number">6</span> 參考文獻</h2><div class="quarto-appendix-contents">
<div class="references csl-bib-body" id="refs" role="doc-bibliography">
<div class="csl-entry" id="ref-carsten_steger_pdf_nodate" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">CARSTEN STEGER, MARKUS ULRICH, CHRISTIAN WIEDEMANN. 机器视觉算法与应用[M]. 杨少荣, 译, 吴迪靖, 译, 段德山, 译. 清华大学出版社.</div>
</div>
<div class="csl-entry" id="ref-zhang_flexible_2000" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">ZHANG Z. <a href="https://doi.org/10.1109/34.888718">A flexible new technique for camera calibration</a>[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2000, 22(11): 1330–1334.</div>
</div>
</div>
</div></section><section class="level2 appendix" data-number="7" id="附錄"><h2 class="quarto-appendix-heading"><span class="header-section-number">7</span> 附錄</h2><div class="quarto-appendix-contents">
<section class="level3" data-number="7.1" id="標定算法的python實現">
<h3 class="anchored" data-anchor-id="標定算法的python實現" data-number="7.1"><span class="header-section-number">7.1</span> 標定算法的Python實現</h3>
<p>OpenCV/Halcon等庫提供了標定用的函數，可以非常方便的用Python或者C++調用。儘管如此，不同的程序庫使用的相機模型有略微的差別。只有真正了解相機模型，理解每一個參數，才能正確地使用它們。</p>
<p>參考Halcon的資料<span class="citation" data-cites="carsten_steger_pdf_nodate"><sup>[<a href="#ref-carsten_steger_pdf_nodate" role="doc-biblioref">1</a>]</sup></span> ，我用Python實現了一份標定算法。經測試，標定結果同Halcon的標定算法所產生的結果一致（誤差小於0.01）。這份代碼對於理解Halcon的相機模型、標定原理可能有幫助，僅供參考。</p>
<details>
<summary>
展開代碼
</summary>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a><span class="im">import</span> cv2 <span class="im">as</span> cv</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a>sin, cos <span class="op">=</span> np.sin, np.cos</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a></span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9" tabindex="-1"></a><span class="co"># 旋转矩阵分解为欧拉角</span></span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10" tabindex="-1"></a><span class="co"># 该函数只能得到其中一种特解</span></span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11" tabindex="-1"></a><span class="co"># 参考：https://www.geometrictools.com/Documentation/EulerAngles.pdf</span></span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12" tabindex="-1"></a><span class="kw">def</span> rotate_matrix_factorize(mat):</span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13" tabindex="-1"></a>    <span class="cf">assert</span>(mat.shape <span class="op">==</span> (<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14" tabindex="-1"></a>    eps <span class="op">=</span> np.finfo(mat.dtype).eps</span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15" tabindex="-1"></a>    r00, r01, r02, r10, r11, r12, r20, r21, r22 <span class="op">=</span> mat.flatten()</span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16" tabindex="-1"></a>    <span class="cf">if</span> np.<span class="bu">abs</span>(r02 <span class="op">-</span> <span class="dv">1</span>) <span class="op">&lt;</span> eps:</span>
<span id="cb1-17"><a aria-hidden="true" href="#cb1-17" tabindex="-1"></a>        <span class="co"># 标定板正好垂直于成像平面，</span></span>
<span id="cb1-18"><a aria-hidden="true" href="#cb1-18" tabindex="-1"></a>        <span class="co"># 分解方式不唯一，</span></span>
<span id="cb1-19"><a aria-hidden="true" href="#cb1-19" tabindex="-1"></a>        <span class="co"># 随便返回一个特解算了</span></span>
<span id="cb1-20"><a aria-hidden="true" href="#cb1-20" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span>, np.pi <span class="op">/</span> <span class="dv">2</span>, np.arctan2(r10, r11)</span>
<span id="cb1-21"><a aria-hidden="true" href="#cb1-21" tabindex="-1"></a>        <span class="co"># </span><span class="al">TODO</span><span class="co">: 把这种标定板剔除掉比较好</span></span>
<span id="cb1-22"><a aria-hidden="true" href="#cb1-22" tabindex="-1"></a>    <span class="cf">elif</span> np.<span class="bu">abs</span>(r01 <span class="op">+</span> <span class="dv">1</span>) <span class="op">&lt;</span> eps:</span>
<span id="cb1-23"><a aria-hidden="true" href="#cb1-23" tabindex="-1"></a>        <span class="co"># 如同上一种情况</span></span>
<span id="cb1-24"><a aria-hidden="true" href="#cb1-24" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span>, <span class="op">-</span>np.pi <span class="op">/</span> <span class="dv">2</span>, np.arctan2(r10, r11)</span>
<span id="cb1-25"><a aria-hidden="true" href="#cb1-25" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-26"><a aria-hidden="true" href="#cb1-26" tabindex="-1"></a>        <span class="cf">return</span> np.arctan2(<span class="op">-</span>r12, r22), np.arcsin(r02), np.arctan2(<span class="op">-</span>r01, r00)</span>
<span id="cb1-27"><a aria-hidden="true" href="#cb1-27" tabindex="-1"></a></span>
<span id="cb1-28"><a aria-hidden="true" href="#cb1-28" tabindex="-1"></a></span>
<span id="cb1-29"><a aria-hidden="true" href="#cb1-29" tabindex="-1"></a><span class="co"># 由投影变换矩阵和内参估计外参</span></span>
<span id="cb1-30"><a aria-hidden="true" href="#cb1-30" tabindex="-1"></a><span class="kw">def</span> estimate_outer_params(cx, cy, fx, fy, mat_h):</span>
<span id="cb1-31"><a aria-hidden="true" href="#cb1-31" tabindex="-1"></a>    <span class="co"># 内参矩阵</span></span>
<span id="cb1-32"><a aria-hidden="true" href="#cb1-32" tabindex="-1"></a>    mat_m <span class="op">=</span> np.matrix([[fx,  <span class="dv">0</span>,  cx],</span>
<span id="cb1-33"><a aria-hidden="true" href="#cb1-33" tabindex="-1"></a>                       [<span class="dv">0</span>,   fy, cy],</span>
<span id="cb1-34"><a aria-hidden="true" href="#cb1-34" tabindex="-1"></a>                       [<span class="dv">0</span>,   <span class="dv">0</span>,  <span class="dv">1</span>]])</span>
<span id="cb1-35"><a aria-hidden="true" href="#cb1-35" tabindex="-1"></a>    lamb <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.linalg.norm(np.matmul(mat_m.I, mat_h[:, <span class="dv">0</span>]))</span>
<span id="cb1-36"><a aria-hidden="true" href="#cb1-36" tabindex="-1"></a>    <span class="co"># 旋转矩阵</span></span>
<span id="cb1-37"><a aria-hidden="true" href="#cb1-37" tabindex="-1"></a>    r1 <span class="op">=</span> lamb <span class="op">*</span> np.matmul(mat_m.I, mat_h[:, <span class="dv">0</span>])</span>
<span id="cb1-38"><a aria-hidden="true" href="#cb1-38" tabindex="-1"></a>    r2 <span class="op">=</span> lamb <span class="op">*</span> np.matmul(mat_m.I, mat_h[:, <span class="dv">1</span>])</span>
<span id="cb1-39"><a aria-hidden="true" href="#cb1-39" tabindex="-1"></a>    r3 <span class="op">=</span> np.cross(r1, r2)</span>
<span id="cb1-40"><a aria-hidden="true" href="#cb1-40" tabindex="-1"></a>    mat_r <span class="op">=</span> np.array([r1, r2, r3]).reshape((<span class="dv">3</span>, <span class="dv">3</span>)).T</span>
<span id="cb1-41"><a aria-hidden="true" href="#cb1-41" tabindex="-1"></a>    <span class="co"># 旋转矩阵要强制转化为正交的</span></span>
<span id="cb1-42"><a aria-hidden="true" href="#cb1-42" tabindex="-1"></a>    u, s, vh <span class="op">=</span> np.linalg.svd(mat_r)</span>
<span id="cb1-43"><a aria-hidden="true" href="#cb1-43" tabindex="-1"></a>    mat_r <span class="op">=</span> np.matmul(np.matmul(u, np.eye(<span class="dv">3</span>, <span class="dv">3</span>)), vh)</span>
<span id="cb1-44"><a aria-hidden="true" href="#cb1-44" tabindex="-1"></a>    <span class="co"># 从旋转矩阵取旋转角度</span></span>
<span id="cb1-45"><a aria-hidden="true" href="#cb1-45" tabindex="-1"></a>    alpha, beta, gamma <span class="op">=</span> rotate_matrix_factorize(mat_r)</span>
<span id="cb1-46"><a aria-hidden="true" href="#cb1-46" tabindex="-1"></a>    <span class="co"># 位移向量</span></span>
<span id="cb1-47"><a aria-hidden="true" href="#cb1-47" tabindex="-1"></a>    t <span class="op">=</span> np.array(lamb <span class="op">*</span> np.matmul(mat_m.I, mat_h[:, <span class="dv">2</span>].reshape(<span class="dv">3</span>, <span class="dv">1</span>)))</span>
<span id="cb1-48"><a aria-hidden="true" href="#cb1-48" tabindex="-1"></a>    <span class="cf">return</span> alpha, beta, gamma, t</span>
<span id="cb1-49"><a aria-hidden="true" href="#cb1-49" tabindex="-1"></a></span>
<span id="cb1-50"><a aria-hidden="true" href="#cb1-50" tabindex="-1"></a></span>
<span id="cb1-51"><a aria-hidden="true" href="#cb1-51" tabindex="-1"></a><span class="kw">def</span> predict1(points, cx, cy, sx, sy, f, kappa, outer_params):</span>
<span id="cb1-52"><a aria-hidden="true" href="#cb1-52" tabindex="-1"></a>    scene_num <span class="op">=</span> outer_params.shape[<span class="dv">0</span>]</span>
<span id="cb1-53"><a aria-hidden="true" href="#cb1-53" tabindex="-1"></a>    pt_num <span class="op">=</span> points.shape[<span class="dv">0</span>]</span>
<span id="cb1-54"><a aria-hidden="true" href="#cb1-54" tabindex="-1"></a>    <span class="cf">assert</span>(outer_params.shape <span class="op">==</span> (scene_num, <span class="dv">6</span>))</span>
<span id="cb1-55"><a aria-hidden="true" href="#cb1-55" tabindex="-1"></a>    <span class="cf">assert</span>(points.shape <span class="op">==</span> (pt_num, <span class="dv">2</span>))</span>
<span id="cb1-56"><a aria-hidden="true" href="#cb1-56" tabindex="-1"></a>    points_transpose <span class="op">=</span> points.T  <span class="co"># shape: (2, pt_num)</span></span>
<span id="cb1-57"><a aria-hidden="true" href="#cb1-57" tabindex="-1"></a>    points_camera <span class="op">=</span> np.empty((<span class="dv">3</span>, pt_num <span class="op">*</span> scene_num))</span>
<span id="cb1-58"><a aria-hidden="true" href="#cb1-58" tabindex="-1"></a></span>
<span id="cb1-59"><a aria-hidden="true" href="#cb1-59" tabindex="-1"></a>    <span class="co"># 变换到相机坐标系</span></span>
<span id="cb1-60"><a aria-hidden="true" href="#cb1-60" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(scene_num):</span>
<span id="cb1-61"><a aria-hidden="true" href="#cb1-61" tabindex="-1"></a>        alpha, beta, gamma, tx, ty, tz <span class="op">=</span> outer_params[i]</span>
<span id="cb1-62"><a aria-hidden="true" href="#cb1-62" tabindex="-1"></a></span>
<span id="cb1-63"><a aria-hidden="true" href="#cb1-63" tabindex="-1"></a>        <span class="co"># 绕z轴旋转。</span></span>
<span id="cb1-64"><a aria-hidden="true" href="#cb1-64" tabindex="-1"></a>        points_rotate_z <span class="op">=</span> np.matmul([</span>
<span id="cb1-65"><a aria-hidden="true" href="#cb1-65" tabindex="-1"></a>            [np.cos(gamma), <span class="op">-</span>np.sin(gamma)],</span>
<span id="cb1-66"><a aria-hidden="true" href="#cb1-66" tabindex="-1"></a>            [np.sin(gamma), np.cos(gamma)]</span>
<span id="cb1-67"><a aria-hidden="true" href="#cb1-67" tabindex="-1"></a>        ],</span>
<span id="cb1-68"><a aria-hidden="true" href="#cb1-68" tabindex="-1"></a>            points_transpose)</span>
<span id="cb1-69"><a aria-hidden="true" href="#cb1-69" tabindex="-1"></a>        <span class="cf">assert</span>(points_rotate_z.shape <span class="op">==</span> (<span class="dv">2</span>, pt_num))</span>
<span id="cb1-70"><a aria-hidden="true" href="#cb1-70" tabindex="-1"></a></span>
<span id="cb1-71"><a aria-hidden="true" href="#cb1-71" tabindex="-1"></a>        <span class="co"># 绕y轴旋转</span></span>
<span id="cb1-72"><a aria-hidden="true" href="#cb1-72" tabindex="-1"></a>        points_rotate_y <span class="op">=</span> np.matmul([</span>
<span id="cb1-73"><a aria-hidden="true" href="#cb1-73" tabindex="-1"></a>            [np.cos(beta), <span class="dv">0</span>],</span>
<span id="cb1-74"><a aria-hidden="true" href="#cb1-74" tabindex="-1"></a>            [<span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb1-75"><a aria-hidden="true" href="#cb1-75" tabindex="-1"></a>            [<span class="op">-</span>np.sin(beta), <span class="dv">0</span>]</span>
<span id="cb1-76"><a aria-hidden="true" href="#cb1-76" tabindex="-1"></a>        ],</span>
<span id="cb1-77"><a aria-hidden="true" href="#cb1-77" tabindex="-1"></a>            points_rotate_z)</span>
<span id="cb1-78"><a aria-hidden="true" href="#cb1-78" tabindex="-1"></a>        <span class="cf">assert</span>(points_rotate_y.shape <span class="op">==</span> (<span class="dv">3</span>, pt_num))</span>
<span id="cb1-79"><a aria-hidden="true" href="#cb1-79" tabindex="-1"></a></span>
<span id="cb1-80"><a aria-hidden="true" href="#cb1-80" tabindex="-1"></a>        <span class="co"># 绕x轴旋转</span></span>
<span id="cb1-81"><a aria-hidden="true" href="#cb1-81" tabindex="-1"></a>        points_rotate_x <span class="op">=</span> np.matmul([</span>
<span id="cb1-82"><a aria-hidden="true" href="#cb1-82" tabindex="-1"></a>            [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb1-83"><a aria-hidden="true" href="#cb1-83" tabindex="-1"></a>            [<span class="dv">0</span>, np.cos(alpha), <span class="op">-</span>np.sin(alpha)],</span>
<span id="cb1-84"><a aria-hidden="true" href="#cb1-84" tabindex="-1"></a>            [<span class="dv">0</span>, np.sin(alpha), np.cos(alpha)]</span>
<span id="cb1-85"><a aria-hidden="true" href="#cb1-85" tabindex="-1"></a>        ], points_rotate_y)</span>
<span id="cb1-86"><a aria-hidden="true" href="#cb1-86" tabindex="-1"></a></span>
<span id="cb1-87"><a aria-hidden="true" href="#cb1-87" tabindex="-1"></a>        <span class="co"># 平移到相机坐标系</span></span>
<span id="cb1-88"><a aria-hidden="true" href="#cb1-88" tabindex="-1"></a>        points_camera[:, i <span class="op">*</span> pt_num: (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num] <span class="op">=</span> points_rotate_x <span class="op">+</span> [[tx], [ty], [tz]]</span>
<span id="cb1-89"><a aria-hidden="true" href="#cb1-89" tabindex="-1"></a></span>
<span id="cb1-90"><a aria-hidden="true" href="#cb1-90" tabindex="-1"></a>    <span class="co"># 投影到成像平面</span></span>
<span id="cb1-91"><a aria-hidden="true" href="#cb1-91" tabindex="-1"></a>    points_image_plane <span class="op">=</span> points_camera[:<span class="dv">2</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :] <span class="op">*</span> f</span>
<span id="cb1-92"><a aria-hidden="true" href="#cb1-92" tabindex="-1"></a>    <span class="cf">assert</span>(points_image_plane.shape <span class="op">==</span> (<span class="dv">2</span>, pt_num <span class="op">*</span> scene_num))</span>
<span id="cb1-93"><a aria-hidden="true" href="#cb1-93" tabindex="-1"></a></span>
<span id="cb1-94"><a aria-hidden="true" href="#cb1-94" tabindex="-1"></a>    <span class="co"># 畸变</span></span>
<span id="cb1-95"><a aria-hidden="true" href="#cb1-95" tabindex="-1"></a>    r2 <span class="op">=</span> np.<span class="bu">sum</span>(np.power(points_image_plane, <span class="dv">2</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-96"><a aria-hidden="true" href="#cb1-96" tabindex="-1"></a>    <span class="cf">assert</span>(r2.shape <span class="op">==</span> (pt_num <span class="op">*</span> scene_num,))</span>
<span id="cb1-97"><a aria-hidden="true" href="#cb1-97" tabindex="-1"></a>    ratio <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> kappa <span class="op">*</span> r2))</span>
<span id="cb1-98"><a aria-hidden="true" href="#cb1-98" tabindex="-1"></a>    points_distort <span class="op">=</span> ratio <span class="op">*</span> points_image_plane</span>
<span id="cb1-99"><a aria-hidden="true" href="#cb1-99" tabindex="-1"></a>    <span class="cf">assert</span>(points_distort.shape <span class="op">==</span> (<span class="dv">2</span>, pt_num <span class="op">*</span> scene_num))</span>
<span id="cb1-100"><a aria-hidden="true" href="#cb1-100" tabindex="-1"></a>    r2d <span class="op">=</span> np.<span class="bu">sum</span>(np.power(points_distort, <span class="dv">2</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-101"><a aria-hidden="true" href="#cb1-101" tabindex="-1"></a>    <span class="cf">assert</span>(r2d.shape <span class="op">==</span> (pt_num <span class="op">*</span> scene_num,))</span>
<span id="cb1-102"><a aria-hidden="true" href="#cb1-102" tabindex="-1"></a></span>
<span id="cb1-103"><a aria-hidden="true" href="#cb1-103" tabindex="-1"></a>    <span class="co"># 到图像坐标系</span></span>
<span id="cb1-104"><a aria-hidden="true" href="#cb1-104" tabindex="-1"></a>    points_image <span class="op">=</span> [[<span class="dv">1</span> <span class="op">/</span> sx], [<span class="dv">1</span> <span class="op">/</span> sy]] <span class="op">*</span> points_distort <span class="op">+</span> [[cx], [cy]]</span>
<span id="cb1-105"><a aria-hidden="true" href="#cb1-105" tabindex="-1"></a>    <span class="cf">assert</span>(points_image.shape <span class="op">==</span> (<span class="dv">2</span>, pt_num <span class="op">*</span> scene_num))</span>
<span id="cb1-106"><a aria-hidden="true" href="#cb1-106" tabindex="-1"></a></span>
<span id="cb1-107"><a aria-hidden="true" href="#cb1-107" tabindex="-1"></a>    <span class="co"># 雅可比矩阵，左起5列对应内参cx, cy, sx, f, kappa，往右每6列对应一组外参</span></span>
<span id="cb1-108"><a aria-hidden="true" href="#cb1-108" tabindex="-1"></a>    <span class="co"># 上半部分对应标定点的横坐标，下半部分对应纵坐标</span></span>
<span id="cb1-109"><a aria-hidden="true" href="#cb1-109" tabindex="-1"></a>    jac <span class="op">=</span> np.empty((<span class="dv">2</span> <span class="op">*</span> pt_num <span class="op">*</span> scene_num, <span class="dv">5</span> <span class="op">+</span> scene_num <span class="op">*</span> <span class="dv">6</span>))</span>
<span id="cb1-110"><a aria-hidden="true" href="#cb1-110" tabindex="-1"></a></span>
<span id="cb1-111"><a aria-hidden="true" href="#cb1-111" tabindex="-1"></a>    <span class="co"># 横坐标对cx的偏导数</span></span>
<span id="cb1-112"><a aria-hidden="true" href="#cb1-112" tabindex="-1"></a>    jac[:pt_num <span class="op">*</span> scene_num, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-113"><a aria-hidden="true" href="#cb1-113" tabindex="-1"></a>    <span class="co"># 纵坐标对cx的偏导数</span></span>
<span id="cb1-114"><a aria-hidden="true" href="#cb1-114" tabindex="-1"></a>    jac[pt_num <span class="op">*</span> scene_num:, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-115"><a aria-hidden="true" href="#cb1-115" tabindex="-1"></a></span>
<span id="cb1-116"><a aria-hidden="true" href="#cb1-116" tabindex="-1"></a></span>
<span id="cb1-117"><a aria-hidden="true" href="#cb1-117" tabindex="-1"></a>    <span class="co"># 对cy的偏导数</span></span>
<span id="cb1-118"><a aria-hidden="true" href="#cb1-118" tabindex="-1"></a>    jac[:pt_num <span class="op">*</span> scene_num, <span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-119"><a aria-hidden="true" href="#cb1-119" tabindex="-1"></a>    jac[pt_num <span class="op">*</span> scene_num:, <span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-120"><a aria-hidden="true" href="#cb1-120" tabindex="-1"></a></span>
<span id="cb1-121"><a aria-hidden="true" href="#cb1-121" tabindex="-1"></a>    <span class="co"># 对sx的偏导数</span></span>
<span id="cb1-122"><a aria-hidden="true" href="#cb1-122" tabindex="-1"></a>    jac[:pt_num <span class="op">*</span> scene_num, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>points_distort[<span class="dv">0</span>, :] <span class="op">/</span> sx <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-123"><a aria-hidden="true" href="#cb1-123" tabindex="-1"></a>    jac[pt_num <span class="op">*</span> scene_num:, <span class="dv">2</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-124"><a aria-hidden="true" href="#cb1-124" tabindex="-1"></a></span>
<span id="cb1-125"><a aria-hidden="true" href="#cb1-125" tabindex="-1"></a>    <span class="co"># 对f求偏导数</span></span>
<span id="cb1-126"><a aria-hidden="true" href="#cb1-126" tabindex="-1"></a>    d_ud_u <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> kappa <span class="op">*</span> points_distort[<span class="dv">0</span>, :] <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> kappa <span class="op">*</span> r2) <span class="op">+</span> ratio</span>
<span id="cb1-127"><a aria-hidden="true" href="#cb1-127" tabindex="-1"></a>    d_ud_v <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> kappa <span class="op">*</span> points_image_plane[<span class="dv">0</span>, :] <span class="op">*</span> points_distort[<span class="dv">1</span>, :] <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> points_image_plane[<span class="dv">1</span>, :] <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> kappa <span class="op">*</span> r2)</span>
<span id="cb1-128"><a aria-hidden="true" href="#cb1-128" tabindex="-1"></a>    d_vd_u <span class="op">=</span> d_ud_v</span>
<span id="cb1-129"><a aria-hidden="true" href="#cb1-129" tabindex="-1"></a>    d_vd_v <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> kappa <span class="op">*</span> points_distort[<span class="dv">1</span>, :] <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> kappa <span class="op">*</span> r2) <span class="op">+</span> ratio</span>
<span id="cb1-130"><a aria-hidden="true" href="#cb1-130" tabindex="-1"></a></span>
<span id="cb1-131"><a aria-hidden="true" href="#cb1-131" tabindex="-1"></a>    jac[:pt_num <span class="op">*</span> scene_num, <span class="dv">3</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> sx <span class="op">*</span> (d_ud_u <span class="op">*</span> points_camera[<span class="dv">0</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :]</span>
<span id="cb1-132"><a aria-hidden="true" href="#cb1-132" tabindex="-1"></a>                                            <span class="op">+</span> d_ud_v <span class="op">*</span> points_camera[<span class="dv">1</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :])).flatten()</span>
<span id="cb1-133"><a aria-hidden="true" href="#cb1-133" tabindex="-1"></a>    jac[pt_num <span class="op">*</span> scene_num:, <span class="dv">3</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> sy <span class="op">*</span> (d_vd_u <span class="op">*</span> points_camera[<span class="dv">0</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :]</span>
<span id="cb1-134"><a aria-hidden="true" href="#cb1-134" tabindex="-1"></a>                                            <span class="op">+</span> d_vd_v <span class="op">*</span> points_camera[<span class="dv">1</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :])).flatten()</span>
<span id="cb1-135"><a aria-hidden="true" href="#cb1-135" tabindex="-1"></a></span>
<span id="cb1-136"><a aria-hidden="true" href="#cb1-136" tabindex="-1"></a>    <span class="co"># 对kappa的偏导数</span></span>
<span id="cb1-137"><a aria-hidden="true" href="#cb1-137" tabindex="-1"></a>    jac[:pt_num <span class="op">*</span> scene_num, <span class="dv">4</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> sx <span class="op">*</span> points_image_plane[<span class="dv">0</span>] <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> kappa <span class="op">*</span> r2) <span class="op">*</span> r2d).flatten()</span>
<span id="cb1-138"><a aria-hidden="true" href="#cb1-138" tabindex="-1"></a>    jac[pt_num <span class="op">*</span> scene_num:, <span class="dv">4</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> sy <span class="op">*</span> points_image_plane[<span class="dv">1</span>] <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> kappa <span class="op">*</span> r2) <span class="op">*</span> r2d).flatten()</span>
<span id="cb1-139"><a aria-hidden="true" href="#cb1-139" tabindex="-1"></a></span>
<span id="cb1-140"><a aria-hidden="true" href="#cb1-140" tabindex="-1"></a>    <span class="co"># 对外参求偏导数</span></span>
<span id="cb1-141"><a aria-hidden="true" href="#cb1-141" tabindex="-1"></a>    <span class="co"># shape: (pt_num * scene_num,)</span></span>
<span id="cb1-142"><a aria-hidden="true" href="#cb1-142" tabindex="-1"></a>    d_c_xc <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> sx <span class="op">*</span> d_ud_u <span class="op">*</span> f <span class="op">/</span> points_camera[<span class="dv">2</span>, :]</span>
<span id="cb1-143"><a aria-hidden="true" href="#cb1-143" tabindex="-1"></a>    d_c_yc <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> sx <span class="op">*</span> d_ud_v <span class="op">*</span> f <span class="op">/</span> points_camera[<span class="dv">2</span>, :]</span>
<span id="cb1-144"><a aria-hidden="true" href="#cb1-144" tabindex="-1"></a>    d_c_zc <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">/</span> sx <span class="op">*</span> (d_ud_u <span class="op">*</span> f <span class="op">*</span> points_camera[<span class="dv">0</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :] <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-145"><a aria-hidden="true" href="#cb1-145" tabindex="-1"></a>                        <span class="op">+</span> d_ud_v <span class="op">*</span> f <span class="op">*</span> points_camera[<span class="dv">1</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :] <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb1-146"><a aria-hidden="true" href="#cb1-146" tabindex="-1"></a>    d_r_xc <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> sy <span class="op">*</span> d_vd_u <span class="op">*</span> f <span class="op">/</span> points_camera[<span class="dv">2</span>, :]</span>
<span id="cb1-147"><a aria-hidden="true" href="#cb1-147" tabindex="-1"></a>    d_r_yc <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> sy <span class="op">*</span> d_vd_v <span class="op">*</span> f <span class="op">/</span> points_camera[<span class="dv">2</span>, :]</span>
<span id="cb1-148"><a aria-hidden="true" href="#cb1-148" tabindex="-1"></a>    d_r_zc <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">/</span> sy <span class="op">*</span> (d_vd_u <span class="op">*</span> f <span class="op">*</span> points_camera[<span class="dv">0</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :] <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-149"><a aria-hidden="true" href="#cb1-149" tabindex="-1"></a>                        <span class="op">+</span> d_vd_v <span class="op">*</span> f <span class="op">*</span> points_camera[<span class="dv">1</span>, :] <span class="op">/</span> points_camera[<span class="dv">2</span>, :] <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb1-150"><a aria-hidden="true" href="#cb1-150" tabindex="-1"></a>    <span class="cf">for</span> scene <span class="kw">in</span> <span class="bu">range</span>(scene_num):</span>
<span id="cb1-151"><a aria-hidden="true" href="#cb1-151" tabindex="-1"></a>        d_c_xc_slice <span class="op">=</span> d_c_xc[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num]</span>
<span id="cb1-152"><a aria-hidden="true" href="#cb1-152" tabindex="-1"></a>        d_c_yc_slice <span class="op">=</span> d_c_yc[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num]</span>
<span id="cb1-153"><a aria-hidden="true" href="#cb1-153" tabindex="-1"></a>        d_c_zc_slice <span class="op">=</span> d_c_zc[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num]</span>
<span id="cb1-154"><a aria-hidden="true" href="#cb1-154" tabindex="-1"></a>        d_r_xc_slice <span class="op">=</span> d_r_xc[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num]</span>
<span id="cb1-155"><a aria-hidden="true" href="#cb1-155" tabindex="-1"></a>        d_r_yc_slice <span class="op">=</span> d_r_yc[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num]</span>
<span id="cb1-156"><a aria-hidden="true" href="#cb1-156" tabindex="-1"></a>        d_r_zc_slice <span class="op">=</span> d_r_zc[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num]</span>
<span id="cb1-157"><a aria-hidden="true" href="#cb1-157" tabindex="-1"></a>        jac_slice1 <span class="op">=</span> jac[scene <span class="op">*</span> pt_num:(scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num, :]</span>
<span id="cb1-158"><a aria-hidden="true" href="#cb1-158" tabindex="-1"></a>        jac_slice2 <span class="op">=</span> jac[(scene_num <span class="op">+</span> scene) <span class="op">*</span> pt_num:(scene_num <span class="op">+</span> scene <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> pt_num, :]</span>
<span id="cb1-159"><a aria-hidden="true" href="#cb1-159" tabindex="-1"></a>        alpha, beta, gamma, _, _, _ <span class="op">=</span> outer_params[scene]</span>
<span id="cb1-160"><a aria-hidden="true" href="#cb1-160" tabindex="-1"></a></span>
<span id="cb1-161"><a aria-hidden="true" href="#cb1-161" tabindex="-1"></a>        <span class="co">#  xc = [cos(beta) * cos(gamma) * x - cos(beta) * sin(gamma) * y],</span></span>
<span id="cb1-162"><a aria-hidden="true" href="#cb1-162" tabindex="-1"></a>        <span class="co">#  yc = [x * (cos(alpha) * sin(gamma) + cos(gamma) * sin(alpha) * sin(beta))</span></span>
<span id="cb1-163"><a aria-hidden="true" href="#cb1-163" tabindex="-1"></a>        <span class="co">#      + y * (cos(alpha) * cos(gamma) - sin(alpha) * sin(beta) * sin(gamma))],</span></span>
<span id="cb1-164"><a aria-hidden="true" href="#cb1-164" tabindex="-1"></a>        <span class="co">#  zc = [x * (-cos(alpha) * cos(gamma) * sin(beta) + sin(alpha) * sin(gamma))</span></span>
<span id="cb1-165"><a aria-hidden="true" href="#cb1-165" tabindex="-1"></a>        <span class="co">#      + y * (cos(alpha) * sin(beta) * sin(gamma) + cos(gamma) * sin(alpha))]</span></span>
<span id="cb1-166"><a aria-hidden="true" href="#cb1-166" tabindex="-1"></a></span>
<span id="cb1-167"><a aria-hidden="true" href="#cb1-167" tabindex="-1"></a>        d_xc_alpha <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-168"><a aria-hidden="true" href="#cb1-168" tabindex="-1"></a>        d_xc_beta <span class="op">=</span> <span class="op">-</span>sin(beta) <span class="op">*</span> cos(gamma) <span class="op">*</span> points_transpose[<span class="dv">0</span>, :] <span class="op">\</span></span>
<span id="cb1-169"><a aria-hidden="true" href="#cb1-169" tabindex="-1"></a>            <span class="op">+</span> sin(beta) <span class="op">*</span> sin(gamma) <span class="op">*</span> points_transpose[<span class="dv">1</span>, :]</span>
<span id="cb1-170"><a aria-hidden="true" href="#cb1-170" tabindex="-1"></a>        d_xc_gamma <span class="op">=</span> <span class="op">-</span>cos(beta) <span class="op">*</span> sin(gamma) <span class="op">*</span> points_transpose[<span class="dv">0</span>, :] <span class="op">\</span></span>
<span id="cb1-171"><a aria-hidden="true" href="#cb1-171" tabindex="-1"></a>            <span class="op">-</span> cos(beta) <span class="op">*</span> cos(gamma) <span class="op">*</span> points_transpose[<span class="dv">1</span>, :]</span>
<span id="cb1-172"><a aria-hidden="true" href="#cb1-172" tabindex="-1"></a>        d_yc_alpha <span class="op">=</span> points_transpose[<span class="dv">0</span>, :] <span class="op">*</span> (<span class="op">-</span>sin(alpha) <span class="op">*</span> sin(gamma) <span class="op">+</span> cos(gamma) <span class="op">*</span> cos(alpha) <span class="op">*</span> sin(beta)) <span class="op">\</span></span>
<span id="cb1-173"><a aria-hidden="true" href="#cb1-173" tabindex="-1"></a>            <span class="op">+</span> points_transpose[<span class="dv">1</span>, :] <span class="op">*</span> (<span class="op">-</span>sin(alpha) <span class="op">*</span> cos(gamma) <span class="op">-</span> cos(alpha) <span class="op">*</span> sin(beta) <span class="op">*</span> sin(gamma))</span>
<span id="cb1-174"><a aria-hidden="true" href="#cb1-174" tabindex="-1"></a>        d_yc_beta <span class="op">=</span> points_transpose[<span class="dv">0</span>, :] <span class="op">*</span> cos(gamma) <span class="op">*</span> sin(alpha) <span class="op">*</span> cos(beta) <span class="op">\</span></span>
<span id="cb1-175"><a aria-hidden="true" href="#cb1-175" tabindex="-1"></a>            <span class="op">-</span> points_transpose[<span class="dv">1</span>, :] <span class="op">*</span> sin(alpha) <span class="op">*</span> cos(beta) <span class="op">*</span> sin(gamma)</span>
<span id="cb1-176"><a aria-hidden="true" href="#cb1-176" tabindex="-1"></a>        d_yc_gamma <span class="op">=</span> points_transpose[<span class="dv">0</span>, :] <span class="op">*</span> (cos(alpha) <span class="op">*</span> cos(gamma) <span class="op">-</span> sin(gamma) <span class="op">*</span> sin(alpha) <span class="op">*</span> sin(beta)) <span class="op">\</span></span>
<span id="cb1-177"><a aria-hidden="true" href="#cb1-177" tabindex="-1"></a>            <span class="op">+</span> points_transpose[<span class="dv">1</span>, :] <span class="op">*</span> (<span class="op">-</span>cos(alpha) <span class="op">*</span> sin(gamma) <span class="op">-</span> sin(alpha) <span class="op">*</span> sin(beta) <span class="op">*</span> cos(gamma))</span>
<span id="cb1-178"><a aria-hidden="true" href="#cb1-178" tabindex="-1"></a>        d_zc_alpha <span class="op">=</span> points_transpose[<span class="dv">0</span>, :] <span class="op">*</span> (sin(alpha) <span class="op">*</span> cos(gamma) <span class="op">*</span> sin(beta) <span class="op">+</span> cos(alpha) <span class="op">*</span> sin(gamma)) <span class="op">\</span></span>
<span id="cb1-179"><a aria-hidden="true" href="#cb1-179" tabindex="-1"></a>            <span class="op">+</span> points_transpose[<span class="dv">1</span>, :] <span class="op">*</span> (<span class="op">-</span>sin(alpha) <span class="op">*</span> sin(beta) <span class="op">*</span> sin(gamma) <span class="op">+</span> cos(gamma) <span class="op">*</span> cos(alpha))</span>
<span id="cb1-180"><a aria-hidden="true" href="#cb1-180" tabindex="-1"></a>        d_zc_beta <span class="op">=</span> points_transpose[<span class="dv">0</span>, :] <span class="op">*</span> <span class="op">-</span>cos(alpha) <span class="op">*</span> cos(gamma) <span class="op">*</span> cos(beta) <span class="op">\</span></span>
<span id="cb1-181"><a aria-hidden="true" href="#cb1-181" tabindex="-1"></a>            <span class="op">+</span> points_transpose[<span class="dv">1</span>, :] <span class="op">*</span> cos(alpha) <span class="op">*</span> cos(beta) <span class="op">*</span> sin(gamma)</span>
<span id="cb1-182"><a aria-hidden="true" href="#cb1-182" tabindex="-1"></a>        d_zc_gamma <span class="op">=</span> points_transpose[<span class="dv">0</span>, :] <span class="op">*</span> (cos(alpha) <span class="op">*</span> sin(gamma) <span class="op">*</span> sin(beta) <span class="op">+</span> sin(alpha) <span class="op">*</span> cos(gamma)) <span class="op">\</span></span>
<span id="cb1-183"><a aria-hidden="true" href="#cb1-183" tabindex="-1"></a>            <span class="op">+</span> points_transpose[<span class="dv">1</span>, :] <span class="op">*</span> (cos(alpha) <span class="op">*</span> sin(beta) <span class="op">*</span> cos(gamma) <span class="op">-</span> sin(gamma) <span class="op">*</span> sin(alpha))</span>
<span id="cb1-184"><a aria-hidden="true" href="#cb1-184" tabindex="-1"></a>        <span class="co"># alpha</span></span>
<span id="cb1-185"><a aria-hidden="true" href="#cb1-185" tabindex="-1"></a>        jac_slice1[:, <span class="dv">5</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_c_xc_slice <span class="op">*</span> d_xc_alpha <span class="op">+</span> d_c_yc_slice <span class="op">*</span> d_yc_alpha <span class="op">+</span> d_c_zc_slice <span class="op">*</span> d_zc_alpha</span>
<span id="cb1-186"><a aria-hidden="true" href="#cb1-186" tabindex="-1"></a>        jac_slice2[:, <span class="dv">5</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_r_xc_slice <span class="op">*</span> d_xc_alpha <span class="op">+</span> d_r_yc_slice <span class="op">*</span> d_yc_alpha <span class="op">+</span> d_r_zc_slice <span class="op">*</span> d_zc_alpha</span>
<span id="cb1-187"><a aria-hidden="true" href="#cb1-187" tabindex="-1"></a></span>
<span id="cb1-188"><a aria-hidden="true" href="#cb1-188" tabindex="-1"></a>        <span class="co"># beta</span></span>
<span id="cb1-189"><a aria-hidden="true" href="#cb1-189" tabindex="-1"></a>        jac_slice1[:, <span class="dv">6</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_c_xc_slice <span class="op">*</span> d_xc_beta <span class="op">+</span> d_c_yc_slice <span class="op">*</span> d_yc_beta <span class="op">+</span> d_c_zc_slice <span class="op">*</span> d_zc_beta</span>
<span id="cb1-190"><a aria-hidden="true" href="#cb1-190" tabindex="-1"></a>        jac_slice2[:, <span class="dv">6</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_r_xc_slice <span class="op">*</span> d_xc_beta <span class="op">+</span> d_r_yc_slice <span class="op">*</span> d_yc_beta <span class="op">+</span> d_r_zc_slice <span class="op">*</span> d_zc_beta</span>
<span id="cb1-191"><a aria-hidden="true" href="#cb1-191" tabindex="-1"></a></span>
<span id="cb1-192"><a aria-hidden="true" href="#cb1-192" tabindex="-1"></a>        <span class="co"># gamma</span></span>
<span id="cb1-193"><a aria-hidden="true" href="#cb1-193" tabindex="-1"></a>        jac_slice1[:, <span class="dv">7</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_c_xc_slice <span class="op">*</span> d_xc_gamma <span class="op">+</span> d_c_yc_slice <span class="op">*</span> d_yc_gamma <span class="op">+</span> d_c_zc_slice <span class="op">*</span> d_zc_gamma</span>
<span id="cb1-194"><a aria-hidden="true" href="#cb1-194" tabindex="-1"></a>        jac_slice2[:, <span class="dv">7</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_r_xc_slice <span class="op">*</span> d_xc_gamma <span class="op">+</span> d_r_yc_slice <span class="op">*</span> d_yc_gamma <span class="op">+</span> d_r_zc_slice <span class="op">*</span> d_zc_gamma</span>
<span id="cb1-195"><a aria-hidden="true" href="#cb1-195" tabindex="-1"></a></span>
<span id="cb1-196"><a aria-hidden="true" href="#cb1-196" tabindex="-1"></a>        <span class="co"># tx</span></span>
<span id="cb1-197"><a aria-hidden="true" href="#cb1-197" tabindex="-1"></a>        jac_slice1[:, <span class="dv">8</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_c_xc_slice</span>
<span id="cb1-198"><a aria-hidden="true" href="#cb1-198" tabindex="-1"></a>        jac_slice2[:, <span class="dv">8</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_r_xc_slice</span>
<span id="cb1-199"><a aria-hidden="true" href="#cb1-199" tabindex="-1"></a></span>
<span id="cb1-200"><a aria-hidden="true" href="#cb1-200" tabindex="-1"></a>        <span class="co"># ty</span></span>
<span id="cb1-201"><a aria-hidden="true" href="#cb1-201" tabindex="-1"></a>        jac_slice1[:, <span class="dv">9</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_c_yc_slice</span>
<span id="cb1-202"><a aria-hidden="true" href="#cb1-202" tabindex="-1"></a>        jac_slice2[:, <span class="dv">9</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_r_yc_slice</span>
<span id="cb1-203"><a aria-hidden="true" href="#cb1-203" tabindex="-1"></a></span>
<span id="cb1-204"><a aria-hidden="true" href="#cb1-204" tabindex="-1"></a>        <span class="co"># tz</span></span>
<span id="cb1-205"><a aria-hidden="true" href="#cb1-205" tabindex="-1"></a>        jac_slice1[:, <span class="dv">10</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_c_zc_slice</span>
<span id="cb1-206"><a aria-hidden="true" href="#cb1-206" tabindex="-1"></a>        jac_slice2[:, <span class="dv">10</span> <span class="op">+</span> scene <span class="op">*</span> <span class="dv">6</span>] <span class="op">=</span> d_r_zc_slice</span>
<span id="cb1-207"><a aria-hidden="true" href="#cb1-207" tabindex="-1"></a>    <span class="cf">return</span> points_image, jac</span>
<span id="cb1-208"><a aria-hidden="true" href="#cb1-208" tabindex="-1"></a></span>
<span id="cb1-209"><a aria-hidden="true" href="#cb1-209" tabindex="-1"></a></span>
<span id="cb1-210"><a aria-hidden="true" href="#cb1-210" tabindex="-1"></a><span class="kw">def</span> calibrate(grids, params):</span>
<span id="cb1-211"><a aria-hidden="true" href="#cb1-211" tabindex="-1"></a>    pattern_size <span class="op">=</span> params[<span class="st">'pattern size'</span>]</span>
<span id="cb1-212"><a aria-hidden="true" href="#cb1-212" tabindex="-1"></a>    cell_width <span class="op">=</span> params[<span class="st">'cell width'</span>]</span>
<span id="cb1-213"><a aria-hidden="true" href="#cb1-213" tabindex="-1"></a>    image_count <span class="op">=</span> grids.shape[<span class="dv">0</span>]</span>
<span id="cb1-214"><a aria-hidden="true" href="#cb1-214" tabindex="-1"></a></span>
<span id="cb1-215"><a aria-hidden="true" href="#cb1-215" tabindex="-1"></a>    <span class="co"># 随机显示一张标定板检测结果</span></span>
<span id="cb1-216"><a aria-hidden="true" href="#cb1-216" tabindex="-1"></a>    <span class="co"># import random</span></span>
<span id="cb1-217"><a aria-hidden="true" href="#cb1-217" tabindex="-1"></a>    <span class="co"># show_grid(pattern_size, imgs, grids, random.randint(0, len(imgs) - 1))</span></span>
<span id="cb1-218"><a aria-hidden="true" href="#cb1-218" tabindex="-1"></a></span>
<span id="cb1-219"><a aria-hidden="true" href="#cb1-219" tabindex="-1"></a>    <span class="co"># 计算世界坐标系中的标定板坐标</span></span>
<span id="cb1-220"><a aria-hidden="true" href="#cb1-220" tabindex="-1"></a>    grid_x <span class="op">=</span> (np.arange(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>]) <span class="op">%</span> pattern_size[<span class="dv">0</span>]) <span class="op">*</span> cell_width</span>
<span id="cb1-221"><a aria-hidden="true" href="#cb1-221" tabindex="-1"></a>    grid_y <span class="op">=</span> np.asarray(np.arange(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>]) <span class="op">/</span> pattern_size[<span class="dv">0</span>], np.<span class="bu">int</span>) <span class="op">*</span> cell_width</span>
<span id="cb1-222"><a aria-hidden="true" href="#cb1-222" tabindex="-1"></a>    grid_world <span class="op">=</span> np.empty((pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>], <span class="dv">2</span>))</span>
<span id="cb1-223"><a aria-hidden="true" href="#cb1-223" tabindex="-1"></a>    grid_world[:, <span class="dv">0</span>] <span class="op">=</span> grid_x</span>
<span id="cb1-224"><a aria-hidden="true" href="#cb1-224" tabindex="-1"></a>    grid_world[:, <span class="dv">1</span>] <span class="op">=</span> grid_y</span>
<span id="cb1-225"><a aria-hidden="true" href="#cb1-225" tabindex="-1"></a></span>
<span id="cb1-226"><a aria-hidden="true" href="#cb1-226" tabindex="-1"></a>    <span class="co"># 提取内参初始值</span></span>
<span id="cb1-227"><a aria-hidden="true" href="#cb1-227" tabindex="-1"></a>    obj_points <span class="op">=</span> np.float32(np.tile(np.hstack((grid_world, np.zeros((grid_world.shape[<span class="dv">0</span>], <span class="dv">1</span>)))), (image_count, <span class="dv">1</span>)))<span class="op">\</span></span>
<span id="cb1-228"><a aria-hidden="true" href="#cb1-228" tabindex="-1"></a>        .reshape(image_count, pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>], <span class="dv">3</span>)</span>
<span id="cb1-229"><a aria-hidden="true" href="#cb1-229" tabindex="-1"></a>    camera_matrix <span class="op">=</span> np.array(cv.initCameraMatrix2D(</span>
<span id="cb1-230"><a aria-hidden="true" href="#cb1-230" tabindex="-1"></a>        obj_points,</span>
<span id="cb1-231"><a aria-hidden="true" href="#cb1-231" tabindex="-1"></a>        np.float32(grids),</span>
<span id="cb1-232"><a aria-hidden="true" href="#cb1-232" tabindex="-1"></a>        (<span class="dv">1280</span>, <span class="dv">1024</span>)</span>
<span id="cb1-233"><a aria-hidden="true" href="#cb1-233" tabindex="-1"></a>    ))</span>
<span id="cb1-234"><a aria-hidden="true" href="#cb1-234" tabindex="-1"></a>    fx, _, cx, _, fy, cy, _, _, _ <span class="op">=</span> camera_matrix.flatten()</span>
<span id="cb1-235"><a aria-hidden="true" href="#cb1-235" tabindex="-1"></a>    sy <span class="op">=</span> <span class="fl">4.8e-3</span></span>
<span id="cb1-236"><a aria-hidden="true" href="#cb1-236" tabindex="-1"></a>    f <span class="op">=</span> fy <span class="op">*</span> sy</span>
<span id="cb1-237"><a aria-hidden="true" href="#cb1-237" tabindex="-1"></a>    sx <span class="op">=</span> f <span class="op">/</span> fx</span>
<span id="cb1-238"><a aria-hidden="true" href="#cb1-238" tabindex="-1"></a>    kappa <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-239"><a aria-hidden="true" href="#cb1-239" tabindex="-1"></a>    outer_params <span class="op">=</span> np.empty((image_count, <span class="dv">6</span>))</span>
<span id="cb1-240"><a aria-hidden="true" href="#cb1-240" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(image_count):</span>
<span id="cb1-241"><a aria-hidden="true" href="#cb1-241" tabindex="-1"></a>        mat_h, _ <span class="op">=</span> cv.findHomography(obj_points[i], grids[i])</span>
<span id="cb1-242"><a aria-hidden="true" href="#cb1-242" tabindex="-1"></a>        alpha, beta, gamma, t <span class="op">=</span> estimate_outer_params(cx, cy, f <span class="op">/</span> sx, f <span class="op">/</span> sy, mat_h)</span>
<span id="cb1-243"><a aria-hidden="true" href="#cb1-243" tabindex="-1"></a>        outer_params[i, :] <span class="op">=</span> [alpha, beta, gamma, t[<span class="dv">0</span>], t[<span class="dv">1</span>], t[<span class="dv">2</span>]]</span>
<span id="cb1-244"><a aria-hidden="true" href="#cb1-244" tabindex="-1"></a></span>
<span id="cb1-245"><a aria-hidden="true" href="#cb1-245" tabindex="-1"></a>    lamb <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb1-246"><a aria-hidden="true" href="#cb1-246" tabindex="-1"></a>    g1 <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb1-247"><a aria-hidden="true" href="#cb1-247" tabindex="-1"></a>    g2 <span class="op">=</span> <span class="fl">1.1</span></span>
<span id="cb1-248"><a aria-hidden="true" href="#cb1-248" tabindex="-1"></a>    i1 <span class="op">=</span> <span class="fl">1e-1</span></span>
<span id="cb1-249"><a aria-hidden="true" href="#cb1-249" tabindex="-1"></a>    i2 <span class="op">=</span> <span class="fl">0.99</span></span>
<span id="cb1-250"><a aria-hidden="true" href="#cb1-250" tabindex="-1"></a>    mat_i <span class="op">=</span> np.eye(<span class="dv">5</span> <span class="op">+</span> <span class="dv">6</span> <span class="op">*</span> image_count)</span>
<span id="cb1-251"><a aria-hidden="true" href="#cb1-251" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):</span>
<span id="cb1-252"><a aria-hidden="true" href="#cb1-252" tabindex="-1"></a>        points_predict, jac <span class="op">=</span> predict1(grid_world, cx, cy, sx, sy, f, kappa, outer_params)</span>
<span id="cb1-253"><a aria-hidden="true" href="#cb1-253" tabindex="-1"></a>        <span class="cf">assert</span>(points_predict.shape <span class="op">==</span> (<span class="dv">2</span>, pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>] <span class="op">*</span> image_count))</span>
<span id="cb1-254"><a aria-hidden="true" href="#cb1-254" tabindex="-1"></a>        delta <span class="op">=</span> points_predict <span class="op">-</span> grids.reshape(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>] <span class="op">*</span> image_count, <span class="dv">2</span>).T</span>
<span id="cb1-255"><a aria-hidden="true" href="#cb1-255" tabindex="-1"></a>        <span class="cf">assert</span>(delta.shape <span class="op">==</span> (<span class="dv">2</span>, pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>] <span class="op">*</span> image_count))</span>
<span id="cb1-256"><a aria-hidden="true" href="#cb1-256" tabindex="-1"></a>        error <span class="op">=</span> np.mean(np.<span class="bu">sum</span>(delta <span class="op">**</span> <span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb1-257"><a aria-hidden="true" href="#cb1-257" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'平均误差：'</span>, np.sqrt(error))</span>
<span id="cb1-258"><a aria-hidden="true" href="#cb1-258" tabindex="-1"></a></span>
<span id="cb1-259"><a aria-hidden="true" href="#cb1-259" tabindex="-1"></a>        <span class="co"># 更新内外参</span></span>
<span id="cb1-260"><a aria-hidden="true" href="#cb1-260" tabindex="-1"></a>        mat_a <span class="op">=</span> np.matmul(jac.T, jac)</span>
<span id="cb1-261"><a aria-hidden="true" href="#cb1-261" tabindex="-1"></a>        step <span class="op">=</span> <span class="op">-</span>np.matmul(np.mat(mat_a <span class="op">+</span> lamb <span class="op">*</span> mat_i).I,</span>
<span id="cb1-262"><a aria-hidden="true" href="#cb1-262" tabindex="-1"></a>                          np.matmul(jac.T, delta.reshape(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>] <span class="op">*</span> image_count <span class="op">*</span> <span class="dv">2</span>, <span class="dv">1</span>)))</span>
<span id="cb1-263"><a aria-hidden="true" href="#cb1-263" tabindex="-1"></a>        <span class="cf">assert</span>(step.size <span class="op">==</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">6</span> <span class="op">*</span> outer_params.shape[<span class="dv">0</span>])</span>
<span id="cb1-264"><a aria-hidden="true" href="#cb1-264" tabindex="-1"></a>        step <span class="op">=</span> np.array(step).flatten()</span>
<span id="cb1-265"><a aria-hidden="true" href="#cb1-265" tabindex="-1"></a>        cx, cy, sx, f, kappa <span class="op">=</span> np.array([cx, cy, sx, f, kappa]) <span class="op">+</span> step[:<span class="dv">5</span>]</span>
<span id="cb1-266"><a aria-hidden="true" href="#cb1-266" tabindex="-1"></a>        outer_params <span class="op">+=</span> step[<span class="dv">5</span>:].reshape(outer_params.shape[<span class="dv">0</span>], <span class="dv">6</span>)</span>
<span id="cb1-267"><a aria-hidden="true" href="#cb1-267" tabindex="-1"></a></span>
<span id="cb1-268"><a aria-hidden="true" href="#cb1-268" tabindex="-1"></a>        <span class="co"># 更新LM算法的参数</span></span>
<span id="cb1-269"><a aria-hidden="true" href="#cb1-269" tabindex="-1"></a>        points_predict2, _ <span class="op">=</span> predict1(grid_world, cx, cy, sx, sy, f, kappa, outer_params)</span>
<span id="cb1-270"><a aria-hidden="true" href="#cb1-270" tabindex="-1"></a>        delta2 <span class="op">=</span> points_predict2 <span class="op">-</span> grids.reshape(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>] <span class="op">*</span> image_count, <span class="dv">2</span>).T</span>
<span id="cb1-271"><a aria-hidden="true" href="#cb1-271" tabindex="-1"></a>        error2 <span class="op">=</span> np.mean(np.<span class="bu">sum</span>(delta2 <span class="op">**</span> <span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb1-272"><a aria-hidden="true" href="#cb1-272" tabindex="-1"></a>        points_predict3 <span class="op">=</span> points_predict <span class="op">+</span> np.matmul(jac, step.reshape(<span class="dv">5</span> <span class="op">+</span> <span class="dv">6</span> <span class="op">*</span> image_count, <span class="dv">1</span>)) <span class="op">\</span></span>
<span id="cb1-273"><a aria-hidden="true" href="#cb1-273" tabindex="-1"></a>            .reshape(<span class="dv">2</span>, pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">0</span>] <span class="op">*</span> image_count)</span>
<span id="cb1-274"><a aria-hidden="true" href="#cb1-274" tabindex="-1"></a>        delta3 <span class="op">=</span> points_predict3 <span class="op">-</span> grids.reshape(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>] <span class="op">*</span> image_count, <span class="dv">2</span>).T</span>
<span id="cb1-275"><a aria-hidden="true" href="#cb1-275" tabindex="-1"></a>        error3 <span class="op">=</span> np.mean(np.<span class="bu">sum</span>(delta3 <span class="op">**</span> <span class="dv">2</span>, axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb1-276"><a aria-hidden="true" href="#cb1-276" tabindex="-1"></a>        p <span class="op">=</span> (error <span class="op">-</span> error2) <span class="op">/</span> (error <span class="op">-</span> error3)</span>
<span id="cb1-277"><a aria-hidden="true" href="#cb1-277" tabindex="-1"></a>        lamb <span class="op">=</span> g2 <span class="op">*</span> lamb <span class="cf">if</span> p <span class="op">&lt;</span> i1 <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb1-278"><a aria-hidden="true" href="#cb1-278" tabindex="-1"></a>            lamb <span class="cf">if</span> i1 <span class="op">&lt;=</span> p <span class="op">&lt;</span> i2 <span class="cf">else</span><span class="op">\</span></span>
<span id="cb1-279"><a aria-hidden="true" href="#cb1-279" tabindex="-1"></a>            g1 <span class="op">*</span> lamb</span>
<span id="cb1-280"><a aria-hidden="true" href="#cb1-280" tabindex="-1"></a></span>
<span id="cb1-281"><a aria-hidden="true" href="#cb1-281" tabindex="-1"></a>    <span class="bu">print</span>(</span>
<span id="cb1-282"><a aria-hidden="true" href="#cb1-282" tabindex="-1"></a>        <span class="st">'''用LM法优化得到：</span></span>
<span id="cb1-283"><a aria-hidden="true" href="#cb1-283" tabindex="-1"></a><span class="st">            cx: </span><span class="sc">%f</span><span class="st"> px;</span></span>
<span id="cb1-284"><a aria-hidden="true" href="#cb1-284" tabindex="-1"></a><span class="st">            cy: </span><span class="sc">%f</span><span class="st"> px;</span></span>
<span id="cb1-285"><a aria-hidden="true" href="#cb1-285" tabindex="-1"></a><span class="st">            sx: </span><span class="sc">%f</span><span class="st"> um;</span></span>
<span id="cb1-286"><a aria-hidden="true" href="#cb1-286" tabindex="-1"></a><span class="st">            sy: </span><span class="sc">%f</span><span class="st"> um;</span></span>
<span id="cb1-287"><a aria-hidden="true" href="#cb1-287" tabindex="-1"></a><span class="st">            f: </span><span class="sc">%f</span><span class="st"> mm;</span></span>
<span id="cb1-288"><a aria-hidden="true" href="#cb1-288" tabindex="-1"></a><span class="st">            kappa: </span><span class="sc">%f</span><span class="st"> 1/m^2;</span></span>
<span id="cb1-289"><a aria-hidden="true" href="#cb1-289" tabindex="-1"></a><span class="st">        '''</span> <span class="op">%</span> (cx, cy, sx <span class="op">*</span> <span class="fl">1e3</span>, sy <span class="op">*</span> <span class="fl">1e3</span>, f, kappa <span class="op">*</span> <span class="fl">1e6</span>)</span>
<span id="cb1-290"><a aria-hidden="true" href="#cb1-290" tabindex="-1"></a>    )</span>
<span id="cb1-291"><a aria-hidden="true" href="#cb1-291" tabindex="-1"></a></span>
<span id="cb1-292"><a aria-hidden="true" href="#cb1-292" tabindex="-1"></a></span>
<span id="cb1-293"><a aria-hidden="true" href="#cb1-293" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb1-294"><a aria-hidden="true" href="#cb1-294" tabindex="-1"></a>    <span class="co"># 初始参数</span></span>
<span id="cb1-295"><a aria-hidden="true" href="#cb1-295" tabindex="-1"></a>    <span class="co"># 实际距离全部以毫米为单位</span></span>
<span id="cb1-296"><a aria-hidden="true" href="#cb1-296" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb1-297"><a aria-hidden="true" href="#cb1-297" tabindex="-1"></a>        <span class="st">'pattern size'</span>: (<span class="dv">7</span>, <span class="dv">7</span>),  <span class="co"># 标记圆的个数</span></span>
<span id="cb1-298"><a aria-hidden="true" href="#cb1-298" tabindex="-1"></a>        <span class="st">'cell width'</span>: <span class="dv">25</span>,  <span class="co"># 标记点间距</span></span>
<span id="cb1-299"><a aria-hidden="true" href="#cb1-299" tabindex="-1"></a>        <span class="st">'sx'</span>: <span class="fl">4.8e-3</span>,</span>
<span id="cb1-300"><a aria-hidden="true" href="#cb1-300" tabindex="-1"></a>        <span class="st">"sy"</span>: <span class="fl">4.8e-3</span></span>
<span id="cb1-301"><a aria-hidden="true" href="#cb1-301" tabindex="-1"></a>    }</span>
<span id="cb1-302"><a aria-hidden="true" href="#cb1-302" tabindex="-1"></a>    pattern_size <span class="op">=</span> params[<span class="st">'pattern size'</span>]</span>
<span id="cb1-303"><a aria-hidden="true" href="#cb1-303" tabindex="-1"></a></span>
<span id="cb1-304"><a aria-hidden="true" href="#cb1-304" tabindex="-1"></a>    <span class="co"># 列出文件夹下的所有图片</span></span>
<span id="cb1-305"><a aria-hidden="true" href="#cb1-305" tabindex="-1"></a>    directory <span class="op">=</span> <span class="st">'./test_images_1'</span></span>
<span id="cb1-306"><a aria-hidden="true" href="#cb1-306" tabindex="-1"></a>    files <span class="op">=</span> []</span>
<span id="cb1-307"><a aria-hidden="true" href="#cb1-307" tabindex="-1"></a></span>
<span id="cb1-308"><a aria-hidden="true" href="#cb1-308" tabindex="-1"></a>    <span class="im">import</span> sys</span>
<span id="cb1-309"><a aria-hidden="true" href="#cb1-309" tabindex="-1"></a>    <span class="im">import</span> os</span>
<span id="cb1-310"><a aria-hidden="true" href="#cb1-310" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> os.listdir(directory):</span>
<span id="cb1-311"><a aria-hidden="true" href="#cb1-311" tabindex="-1"></a>        path <span class="op">=</span> os.path.join(directory, <span class="bu">file</span>)</span>
<span id="cb1-312"><a aria-hidden="true" href="#cb1-312" tabindex="-1"></a>        <span class="cf">if</span> os.path.isfile(path) <span class="kw">and</span> path.endswith(<span class="st">'.bmp'</span>):</span>
<span id="cb1-313"><a aria-hidden="true" href="#cb1-313" tabindex="-1"></a>            files.append(path)</span>
<span id="cb1-314"><a aria-hidden="true" href="#cb1-314" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(files) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb1-315"><a aria-hidden="true" href="#cb1-315" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"至少需要两份标定文件！"</span>, sys.stderr)</span>
<span id="cb1-316"><a aria-hidden="true" href="#cb1-316" tabindex="-1"></a>        <span class="co"># exit(128)</span></span>
<span id="cb1-317"><a aria-hidden="true" href="#cb1-317" tabindex="-1"></a></span>
<span id="cb1-318"><a aria-hidden="true" href="#cb1-318" tabindex="-1"></a>    <span class="co"># 读取图片</span></span>
<span id="cb1-319"><a aria-hidden="true" href="#cb1-319" tabindex="-1"></a>    imgs <span class="op">=</span> []</span>
<span id="cb1-320"><a aria-hidden="true" href="#cb1-320" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> files:</span>
<span id="cb1-321"><a aria-hidden="true" href="#cb1-321" tabindex="-1"></a>        imgs.append(cv.imread(<span class="bu">file</span>, cv.IMREAD_GRAYSCALE))</span>
<span id="cb1-322"><a aria-hidden="true" href="#cb1-322" tabindex="-1"></a></span>
<span id="cb1-323"><a aria-hidden="true" href="#cb1-323" tabindex="-1"></a>    <span class="co"># 检测圆点</span></span>
<span id="cb1-324"><a aria-hidden="true" href="#cb1-324" tabindex="-1"></a>    grids <span class="op">=</span> np.zeros((<span class="bu">len</span>(imgs), params[<span class="st">'pattern size'</span>][<span class="dv">0</span>] <span class="op">*</span> params[<span class="st">'pattern size'</span>][<span class="dv">1</span>], <span class="dv">2</span>))</span>
<span id="cb1-325"><a aria-hidden="true" href="#cb1-325" tabindex="-1"></a></span>
<span id="cb1-326"><a aria-hidden="true" href="#cb1-326" tabindex="-1"></a>    <span class="co"># 有兩種方法可以讀取坐標：</span></span>
<span id="cb1-327"><a aria-hidden="true" href="#cb1-327" tabindex="-1"></a>    <span class="co"># 1. 直接從halcon的識別結果中讀取坐標（halcon的檢測結果更準）；</span></span>
<span id="cb1-328"><a aria-hidden="true" href="#cb1-328" tabindex="-1"></a>    <span class="co"># 2. 或者調用opencv的檢測算法讀取坐標。</span></span>
<span id="cb1-329"><a aria-hidden="true" href="#cb1-329" tabindex="-1"></a>    <span class="co"># 注釋掉你不用的那個方法。</span></span>
<span id="cb1-330"><a aria-hidden="true" href="#cb1-330" tabindex="-1"></a></span>
<span id="cb1-331"><a aria-hidden="true" href="#cb1-331" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb1-332"><a aria-hidden="true" href="#cb1-332" tabindex="-1"></a><span class="co">    # 直接取halcon识别结果</span></span>
<span id="cb1-333"><a aria-hidden="true" href="#cb1-333" tabindex="-1"></a><span class="co">    for i, file in enumerate(files):</span></span>
<span id="cb1-334"><a aria-hidden="true" href="#cb1-334" tabindex="-1"></a><span class="co">        with open(file + '.d', 'r') as file_halcon_result:</span></span>
<span id="cb1-335"><a aria-hidden="true" href="#cb1-335" tabindex="-1"></a><span class="co">            lines = file_halcon_result.readlines()</span></span>
<span id="cb1-336"><a aria-hidden="true" href="#cb1-336" tabindex="-1"></a><span class="co">            for j, line in enumerate(lines):</span></span>
<span id="cb1-337"><a aria-hidden="true" href="#cb1-337" tabindex="-1"></a><span class="co">                coord = line.strip().split(' ')</span></span>
<span id="cb1-338"><a aria-hidden="true" href="#cb1-338" tabindex="-1"></a><span class="co">                if len(coord) != 2:</span></span>
<span id="cb1-339"><a aria-hidden="true" href="#cb1-339" tabindex="-1"></a><span class="co">                    continue</span></span>
<span id="cb1-340"><a aria-hidden="true" href="#cb1-340" tabindex="-1"></a><span class="co">                grids[i, j, 0] = float(coord[0])</span></span>
<span id="cb1-341"><a aria-hidden="true" href="#cb1-341" tabindex="-1"></a><span class="co">                grids[i, j, 1] = float(coord[1])</span></span>
<span id="cb1-342"><a aria-hidden="true" href="#cb1-342" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb1-343"><a aria-hidden="true" href="#cb1-343" tabindex="-1"></a></span>
<span id="cb1-344"><a aria-hidden="true" href="#cb1-344" tabindex="-1"></a>    <span class="co"># 从图片提取圆点</span></span>
<span id="cb1-345"><a aria-hidden="true" href="#cb1-345" tabindex="-1"></a>    <span class="cf">for</span> i, img <span class="kw">in</span> <span class="bu">enumerate</span>(imgs):</span>
<span id="cb1-346"><a aria-hidden="true" href="#cb1-346" tabindex="-1"></a>        success, centers <span class="op">=</span> cv.findCirclesGrid(img, pattern_size)</span>
<span id="cb1-347"><a aria-hidden="true" href="#cb1-347" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> success:</span>
<span id="cb1-348"><a aria-hidden="true" href="#cb1-348" tabindex="-1"></a>            <span class="cf">return</span> {</span>
<span id="cb1-349"><a aria-hidden="true" href="#cb1-349" tabindex="-1"></a>                <span class="st">'success'</span>: <span class="va">False</span>,</span>
<span id="cb1-350"><a aria-hidden="true" href="#cb1-350" tabindex="-1"></a>                <span class="st">'msg'</span>: <span class="st">'标定板无法识别'</span>,</span>
<span id="cb1-351"><a aria-hidden="true" href="#cb1-351" tabindex="-1"></a>                <span class="st">'error code 1'</span>: <span class="dv">123</span>,</span>
<span id="cb1-352"><a aria-hidden="true" href="#cb1-352" tabindex="-1"></a>                <span class="st">'error code 2'</span>: i</span>
<span id="cb1-353"><a aria-hidden="true" href="#cb1-353" tabindex="-1"></a>            }</span>
<span id="cb1-354"><a aria-hidden="true" href="#cb1-354" tabindex="-1"></a>        <span class="cf">assert</span>(centers.shape <span class="op">==</span> (pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>], <span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb1-355"><a aria-hidden="true" href="#cb1-355" tabindex="-1"></a>        grids[i, :, :] <span class="op">=</span> centers.reshape(pattern_size[<span class="dv">0</span>] <span class="op">*</span> pattern_size[<span class="dv">1</span>], <span class="dv">2</span>)</span>
<span id="cb1-356"><a aria-hidden="true" href="#cb1-356" tabindex="-1"></a>    calibrate(grids, params)</span>
<span id="cb1-357"><a aria-hidden="true" href="#cb1-357" tabindex="-1"></a></span>
<span id="cb1-358"><a aria-hidden="true" href="#cb1-358" tabindex="-1"></a></span>
<span id="cb1-359"><a aria-hidden="true" href="#cb1-359" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb1-360"><a aria-hidden="true" href="#cb1-360" tabindex="-1"></a>    main()</span></code><button class="code-copy-button" title="复制到剪贴板"><i class="bi"></i></button></pre></div>
</details>
</section>
<section class="level3" data-number="7.2" id="版權信息">
<h3 class="anchored" data-anchor-id="版權信息" data-number="7.2"><span class="header-section-number">7.2</span> 版權信息</h3>
<p>圖像：</p>
<ul>
<li><a href="#fig-cam_coord_system">圖 1</a> 基於<a href="https://wordpress.org/openverse/image/0e1d381b-fa16-4478-953b-beca85a5d967">此圖</a>修改而來。原圖許可證：<a href="https://creativecommons.org/licenses/by/2.0/?ref=openverse&amp;atype=rich">CC BY 2.0</a>。</li>
<li><a href="#fig-pinhole_model">圖 2</a> 和 <a href="#fig-pinhole_model_simplified">圖 3</a> 基於<a href="https://www.svgrepo.com/svg/39292/candle">此圖</a>修改而來。原圖許可證：<a href="https://www.svgrepo.com/page/licensing">CC0 License</a>。</li>
<li><a href="#fig-barrel_distortion">圖 5</a> 來自於<a href="https://wordpress.org/openverse/image/a9279a80-f137-48dd-96ad-693c6d6e6b50">此</a>。許可詳情：<a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY-NC-ND 2.0</a></li>
<li><a href="#fig-calibration_board">圖 6</a> 的來源與許可詳情見<a href="https://wordpress.org/openverse/image/7643d624-15b3-47c5-ae7b-b2e99ed6ce5c">此</a>。</li>
</ul>
</section>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
</div>
    </div>
    <div class="post_list">
        <span>By </span>
        <a href="./">@執迷</a>
        <span> in </span>
        <span class="post_category"><a href="./" rel="bookmark" title="Permalink to 計算機視覺">[ 計算機視覺 ]</a></span>
        <span class="post_date">2022-02-22</span>
        <div><span>Tags : </span>
            
            
            <span><a href="./">#相機標定, </a></span>
            
            <span><a href="./">#相機模型, </a></span>
            
            <span><a href="./">#張氏標定法, </a></span>
            
            
        </div>

        <div class="entry-social">
            <span class="twitter"><a target="_blank" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;" title="Twitter" href="https://twitter.com/share?url=././calibration_20220222.html&text=相機模型和相機標定&via="><img src="./theme/images/icons/twitter-s.png"></a></span>

            <span class="gplus"><a target="_blank" title="Google +" href="https://plus.google.com/share?url=././calibration_20220222.html&hl=fr" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="./theme/images/icons/google-s.png"></a></span>

            <span class="facebook"><a target="_blank" title="Facebook" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=500,width=700');return false;" href="https://www.facebook.com/sharer.php?u=././calibration_20220222.html&t=相機模型和相機標定"><img src="./theme/images/icons/facebook-s.png"></a></span>

            <a  target="_blank" title="Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=././calibration_20220222.html&title=相機模型和相機標定" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="./theme/images/icons/linkedin-s.png"></a>

            <span class="mail"><a href="mailto:?subject=相機模型和相機標定&amp;body=Viens découvrir un article à propos de [相機模型和相機標定] sur le site de 執迷. ././calibration_20220222.html" title="Share by Email" target="_blank"><img src="./theme/images/icons/mail-s.png"></a></span>
        </div>
    </div>
    

</section>

<!-- Quarto Clipboard -->
<script type="text/javascript">
    var clipboard = new ClipboardJS(
        '.code-copy-button',
        {
            target: function(trigger) {
                console.log("Copy texts. ", trigger);
                return trigger.previousElementSibling;
            }
        }
    );    
    clipboard.on('success', function(e) {
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        e.clearSelection();
        alert('Copied!');
    });
    console.log("ClipboardJS loaded.");
</script>

  </article>

  <!-- Footer -->
  <footer>
    <p>
      Blog powered by <a href="http://getpelican.com/">Pelican</a>, 
      which takes great advantage of <a href="http://python.org">Python</a>.
      Theme <a href="https://github.com/parbhat/pelican-blue">Pelican-Blue</a> by <a href="https://parbhatpuri.com/">@parbhat</a>.
    </p>
    
      
      <span id="busuanzi_container_site_pv">總訪問量<span id="busuanzi_value_site_pv"></span></span>
      <span id="busuanzi_container_site_uv">
        訪客數<span id="busuanzi_value_site_uv"></span>
      </span>
      
    
  </footer>
</body>
</html>