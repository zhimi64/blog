<!doctype html>
<html lang="" itemscope itemtype="http://schema.org/Person">
<head>

  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G3N739QVFZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-G3N739QVFZ');
  </script>
  

  
  <script>
    window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
  </script>
  <script defer src="./_vercel/insights/script.js"></script>
  

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  
  

<!-- Quarto -->
<link href="./theme/css/quarto/quarto.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>
<script src="./theme/scripts/quarto/quarto.js"></script>


  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>Lean语言数学之旅——命题逻辑</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="介绍了如何在Lean中证明一个定理。命题逻辑涉及命题与命题之间的关系，有时又被称为零阶逻辑。命题指的是一个可以判断真假的陈述句，根据其真假命题可以分为真命题或假命题。本章介绍了命题逻辑的与、或、非运算在Lean中的实现以及应用方式。文章给出了一些可供练习的习题和参考答案。">
  <meta name="author" content="執迷">

  <link rel="shortcut icon" href="favicon.ico">

  <!-- schema.org -->
  <meta itemprop="name" content="執迷的博客">
  <meta itemprop="image" content="">
  <meta itemprop="description" content="介绍了如何在Lean中证明一个定理。命题逻辑涉及命题与命题之间的关系，有时又被称为零阶逻辑。命题指的是一个可以判断真假的陈述句，根据其真假命题可以分为真命题或假命题。本章介绍了命题逻辑的与、或、非运算在Lean中的实现以及应用方式。文章给出了一些可供练习的习题和参考答案。">

  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
  <!-- Style Meta Data -->
  <link rel="stylesheet" href="./theme/css/style.css" type="text/css" />
  <link rel="stylesheet" href="./theme/css/pygments.css" type="text/css" />

  <!-- Feed Meta Data -->
  
  

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="">
  
<meta name="twitter:creator" content="">
<meta name="twitter:url" content="././lean_logic_20250111_zh-cn.html">
<meta name="twitter:title" content="執迷的博客 ~ Lean语言数学之旅——命题逻辑">
<meta name="twitter:description" content="">

<!-- Facebook Meta Data -->
<meta property="og:title" content="執迷的博客 ~ Lean语言数学之旅——命题逻辑" />
<meta property="og:description" content="" />
<meta property="og:image" content="" />


<!-- MathJax -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>




</head>

<body>
  <!-- Sidebar -->
  <aside>
    <!--<center><a href="."><img id="avatar" src=""></a></center>-->
    <h1>執迷的博客</h1>
    
      <p>做一個有趣的人！</p>
    
    <br>

    

    <nav class="nav">
      <ul class="list-bare">
      
        
          <li><a class="nav__link" href="./index_zh-cn.html">Blog</a></li>
        
         
        
          <li><a class="nav__link" href="././about_zh-cn.html">About</a></li>
        
         
      </ul>
    </nav>

    <p class="social">
      
      
      
    </p>

    <!--
    
    -->
  </aside>

  <!-- Content -->
  <article>
    
<section id="content">
    <h2 class="post_title post_detail"><a href="././lean_logic_20250111_zh-cn.html" rel="bookmark" title="Permalink to Lean语言数学之旅——命题逻辑">Lean语言数学之旅——命题逻辑</a></h2>
    
    <p>
        <span id="busuanzi_container_page_pv">
            本文瀏覽次數<span id="busuanzi_value_page_pv"></span>
        </span>
    </p>
    
    <div class="entry-content blog-post">
        <div>
<div class="page-columns page-rows-contents page-layout-article" id="quarto-content">
<div class="sidebar margin-sidebar" id="quarto-margin-sidebar">
<nav class="toc-active" id="TOC" role="doc-toc">
<h2 id="toc-title">目录</h2>
<ul>
<li><a class="nav-link active" data-scroll-target="#命題邏輯" href="#命題邏輯" id="toc-命題邏輯"><span class="header-section-number">1</span> 命题逻辑</a></li>
<li><a class="nav-link" data-scroll-target="#命題的證明" href="#命題的證明" id="toc-命題的證明"><span class="header-section-number">2</span> 命题的证明</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#公理" href="#公理" id="toc-公理"><span class="header-section-number">2.1</span> 公理</a></li>
<li><a class="nav-link" data-scroll-target="#類型即命題" href="#類型即命題" id="toc-類型即命題"><span class="header-section-number">2.2</span> 类型即命题</a></li>
<li><a class="nav-link" data-scroll-target="#編寫證明" href="#編寫證明" id="toc-編寫證明"><span class="header-section-number">2.3</span> 编写证明</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#與運算" href="#與運算" id="toc-與運算"><span class="header-section-number">2.3.1</span> 与运算</a></li>
<li><a class="nav-link" data-scroll-target="#或運算" href="#或運算" id="toc-或運算"><span class="header-section-number">2.3.2</span> 或运算</a></li>
<li><a class="nav-link" data-scroll-target="#非運算" href="#非運算" id="toc-非運算"><span class="header-section-number">2.3.3</span> 非运算</a></li>
<li><a class="nav-link" data-scroll-target="#等價關係" href="#等價關係" id="toc-等價關係"><span class="header-section-number">2.3.4</span> 等价关系</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#一些有用的工具" href="#一些有用的工具" id="toc-一些有用的工具"><span class="header-section-number">2.4</span> 一些有用的工具</a>
<ul class="collapse">
<li><a class="nav-link" data-scroll-target="#show關鍵詞" href="#show關鍵詞" id="toc-show關鍵詞"><span class="header-section-number">2.4.1</span> <code>show</code>关键词</a></li>
<li><a class="nav-link" data-scroll-target="#let關鍵詞" href="#let關鍵詞" id="toc-let關鍵詞"><span class="header-section-number">2.4.2</span> <code>let</code>关键词</a></li>
<li><a class="nav-link" data-scroll-target="#have關鍵詞" href="#have關鍵詞" id="toc-have關鍵詞"><span class="header-section-number">2.4.3</span> <code>have</code>关键词</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#練習一" href="#練習一" id="toc-練習一"><span class="header-section-number">2.5</span> 练习一</a></li>
<li><a class="nav-link" data-scroll-target="#練習二-經典邏輯" href="#練習二-經典邏輯" id="toc-練習二-經典邏輯"><span class="header-section-number">2.6</span> 练习二-经典逻辑</a></li>
</ul></li>
<li><a class="nav-link" data-scroll-target="#總結" href="#總結" id="toc-總結"><span class="header-section-number">3</span> 总结</a></li>
</ul>
</nav>
</div>
<main class="content" id="quarto-document-content">
<header class="quarto-title-block default" id="title-block-header">
<div class="quarto-title">

</div>
<div class="quarto-title-meta">
<div>
<div class="quarto-title-meta-heading">发布于</div>
<div class="quarto-title-meta-contents">
<p class="date">2025年1月12日</p>
</div>
</div>
</div>
</header>
<div class="hidden">
<link href="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/styles/default.min.css" rel="stylesheet"/>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
<script src="https://unpkg.com/highlightjs-lean/dist/lean.min.js" type="text/javascript"></script>
<script type="text/javascript">
  hljs.highlightAll();
</script>
<style>
.lean {background-color: GhostWhite;}
</style>
</div>
<p>上一章介绍了Lean的一些基本概念和环境配置。本章开始，我们将介绍如何证明一个定理。让我们先从基础的命题逻辑开始。</p>
<section class="level1" data-number="1" id="命題邏輯">

<p>命题逻辑涉及命题与命题之间的关系，有时又被称为零阶逻辑。</p>
<p>命题指的是一个可以判断真假的陈述句，根据其真假命题可以分为真命题或假命题。例如</p>
<ul>
<li>√2是无理数</li>
<li>有无穷多个自然数</li>
<li>矩阵乘法没有交换律</li>
<li>2012年，世界末日到来</li>
</ul>
<p>以上各种陈述句或真或假，都属于命题。</p>
<pre class="lean"><code>section
  variable (p q r : Prop)</code></pre>
<p>在Lean中，命题的类型为<code>Prop</code>。上面的代码声明了三个命题p、q和r。</p>
<p>定义在命题上的基本运算包括与运算、或运算、非运算等。在Lean中，<code>And</code>运算即命题的与运算：</p>
<pre class="lean"><code>  #check And     -- 与运算
  -- 输出为：And (a b : Prop) : Prop
  #check And p q -- 表示p和q都是真命题
  #check p ∧ q   -- And p q 的另一种写法</code></pre>
<p>上面的代码中演示了“与”的运算，其中<code>#check</code>用于输出算式的类型。与运算可以使用<code>And</code>或<code>∧</code>符号构造，符号<code>∧</code>可以在编辑器中用<code>\and</code>打出。</p>
<p>类似的，下面是或运算、非运算等运算的用法。</p>
<pre class="lean"><code>  #check Or     -- 或运算
  -- 输出为：Or (a b : Prop) : Prop
  #check Or p q -- 表示p或q其中之一是真命题
  #check p ∨ q  -- Or p q 的另一种写法
  -- ∨ 可以在编辑器中用\or打出

  #check Not    -- 非
  #check Not p  -- 表示p是假命题
  #check ¬p     -- Not p 的另一种写法
  -- ¬ 可以在编辑器中用\not打出

  #check p → q  -- 蕴含关系，表示如果p为真，那么q也为真
  -- → 可以在编辑器中用\to或者\r打出
  #check p ↔ q  -- 表示p成立当且仅当q成立
  -- ↔ 可以在编辑器中用\lr打出

end</code></pre>
</section>
<section class="level1" data-number="2" id="命題的證明">

<section class="level2" data-number="2.1" id="公理">
<h2 class="anchored" data-anchor-id="公理" data-number="2.1"><span class="header-section-number">2.1</span> 公理</h2>
<p>公理是不言自明的真命题，是不需要证明的。</p>
<p>下面的例子中，我在<code>crazy_axioms</code>命名空间下声明了一个公理：</p>
<pre class="lean"><code>namespace crazy_axioms
  -- 声明了一个命题p
  variable (p : Prop)
  -- 声明了一个公理em
  -- 该公理的含义是：对于任意的命题p，p要么为真，要么为假。
  -- 它被叫做排中律（Law Of Excluded Middle）
  axiom em : p ∨ ¬p
end crazy_axioms

#check crazy_axioms.em
-- 类型为：em (p : Prop) : p ∨ ¬p</code></pre>
<p>公理em的类型是<code>p ∨ ¬p</code>，表示对于任意的命题p，p要么为真，要么为假。</p>
<p>我不提供em的证明，因为它是公理。你可以拒绝一个公理或者接受一个公理，可以讨论一个公理的引入是否合理。但只要我们引入了它，就默认它是真的。</p>
<p>我将其放在crazy_axioms命名空间下。如果不想使用这个公理，你需要避免在代码中使用crazy_axioms这个命名空间。</p>
</section>
<section class="level2" data-number="2.2" id="類型即命題">
<h2 class="anchored" data-anchor-id="類型即命題" data-number="2.2"><span class="header-section-number">2.2</span> 类型即命题</h2>
<p>接下来说明如何在Lean中证明一个命题为真。</p>
<p>在Lean中，命题也是一种类型。<strong>对于任意命题，如果你能构造类型为该命题的实例，就相当于证明这个命题为真。</strong></p>
<p>下面将展示一些具体的例子。我们要证明：</p>
<pre class="lean"><code>section
  variable (p : Prop)
  example : ¬p ∨ ¬¬p := sorry
end</code></pre>
<p>在Lean中，作为练习，我们经常会证明一些不重要的定理，我们懒得给它们取名字，这时我们使用<code>example</code>.</p>
<p>我们暂时没有给出<code>¬p ∨ ¬¬p</code>的证明，因此我们将证明设为<code>sorry</code>，表示我们暂时给不了证明，但是请Lean不要报错。</p>
<p>上面的写法也等价于：</p>
<pre class="lean"><code>example (p : Prop) : ¬p ∨ ¬¬p := sorry</code></pre>
<p>即可以将变量p的声明与定理合并在一行。</p>
<p>加下来我们给出如何证明。<code>p</code>是一个命题，因此<code>p</code>的否定<code>¬p</code>也是一个命题。假如我们将其应用于em公理，将会得到什么呢？</p>
<pre class="lean"><code>section
  variable (p : Prop)
  #check crazy_axioms.em ¬p -- crazy_axioms.em ¬p : ¬p ∨ ¬¬p
end</code></pre>
<p>我们得到了一个类型为<code>¬p ∨ ¬¬p</code>的实例。因此，它可以作为<code>¬p ∨ ¬¬p</code>的证明。</p>
<pre class="lean"><code>example {p : Prop} : ¬p ∨ ¬¬p := crazy_axioms.em ¬p</code></pre>
<p>在Lean中，我们使用<code>theorem</code>来定义定理。<code>theorem</code>就是有名字的<code>example</code>。</p>
<pre class="lean"><code>theorem np_or_nnp {p : Prop} : ¬p ∨ ¬¬p := crazy_axioms.em ¬p
#check np_or_nnp -- 类型为 ¬p ∨ ¬¬p</code></pre>
<p>我们将得到的新命题命名为np_or_nnp，这实际上是一个返回类型为<code>¬p ∨ ¬¬p</code>的函数，我们用<code>crazy_axioms.em ¬p</code>作为它的返回值。</p>
<p>综上所述，我们这么理解Lean中的证明过程： 一条定理实际上是一个函数。这个函数的输入是定理使用的变量或者前提，输出类型是定理所对应的命题，我们需要构造一个满足类型要求的返回值作为其证明。</p>
<p>类型的证明也并不总是需要引用公理或先前的命题。下面是一个例子。</p>
<pre class="lean"><code>example {p q: Prop} : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp</code></pre>
<p>在这个例子中，我们需要构造一个类型为<code>p → q → p</code>的值。</p>
<p>注意Lean中，<code>→</code>符号是右结合的，所以<code>p → q → p</code>表示的是<code>p → (q → p)</code>. 函数<code>fun hp : p =&gt; fun hq : q =&gt; hp</code>的类型恰为<code>p → q → p</code>，这就完成了证明。</p>
<p>注意如果函数的输入类型为<code>a</code>，输出类型为<code>b</code>，那么函数的类型为<code>a → b</code>，恰好对应著“<code>a</code>蕴含<code>b</code>”这一命题。</p>
<p>接下来，让我们正式著手证明一些命题。</p>
</section>
<section class="level2" data-number="2.3" id="編寫證明">
<h2 class="anchored" data-anchor-id="編寫證明" data-number="2.3"><span class="header-section-number">2.3</span> 编写证明</h2>
<section class="level3" data-number="2.3.1" id="與運算">
<h3 class="anchored" data-anchor-id="與運算" data-number="2.3.1"><span class="header-section-number">2.3.1</span> 与运算</h3>
<p><code>p ∧ q</code>表示命题p和命题q同时成立，其定义为：</p>
<pre class="lean"><code>#print And
-- 输出：
-- structure And (a b : Prop) : Prop
-- number of parameters: 2
-- fields:
--   And.left : a
--   And.right : b
-- constructor:
--   And.intro {a b : Prop} (left : a) (right : b) : a ∧ b</code></pre>
<p>可见<code>And</code>是一个结构体，包含<code>left</code>和<code>right</code>两个字段，并且有一个构造函数<code>And.intro</code>.</p>
<p><code>And.left</code>的用法如下：</p>
<div class="theorem example" id="exm-and-left">
<p><span class="theorem-title"><strong>例 1</strong></span> <strong>And.left</strong></p>
<pre class="lean"><code>example {p q : Prop} : p ∧ q → p := fun h : p ∧ q =&gt; h.left</code></pre>
<p>这个例子中，<code>h</code>的类型为<code>And p q</code>，因此<code>h.left</code>的类型为<code>p</code>.</p>
<p>上面的证明也可以写成：</p>
<pre class="lean"><code>example {p q : Prop} : p ∧ q → p := fun h : p ∧ q =&gt; And.left h</code></pre>
</div>
<p>接下来，请仿照<code>And.left</code>的用法，使用<code>And.right</code>完成练习。</p>
<div class="theorem exercise" id="exr-and-right">
<p><span class="theorem-title"><strong>习题 1</strong></span>  </p>
证明<code>p ∧ q → q</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∧ q → q := fun h =&gt; h.right</code></pre>
</details>
</div>
<div class="theorem example" id="exm-and-intro">
<p><span class="theorem-title"><strong>例 2</strong></span> <strong>And.intro</strong></p>
<p><code>And.intro</code>是<code>And</code>的构造函数，其用法如下：</p>
<pre class="lean"><code>example  {p q : Prop} : p → q → p ∧ q :=
  fun hp : p =&gt;
    fun hq : q =&gt;
      And.intro hp hq</code></pre>
</div>
<p>该例子表明给定条件<code>p</code>和<code>q</code>成立，就有<code>p ∧ q</code>成立。</p>
<div class="theorem exercise" id="exr-and-intro">
<p><span class="theorem-title"><strong>习题 2</strong></span> <strong>And的交换律</strong></p>
证明：<code>p ∧ q → q ∧ p</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example  {p q : Prop} : p ∧ q → q ∧ p :=
  fun h : p ∧ q =&gt;
    And.intro h.right h.left</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-and-idempotent">
<p><span class="theorem-title"><strong>习题 3</strong></span> <strong>And的幂等律</strong></p>
证明：<code>p ∧ p → p</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example  {p : Prop} : p ∧ p → p :=
  fun h : p ∧ p =&gt;
    h.left</code></pre>
</details>
</div>
</section>
<section class="level3" data-number="2.3.2" id="或運算">
<h3 class="anchored" data-anchor-id="或運算" data-number="2.3.2"><span class="header-section-number">2.3.2</span> 或运算</h3>
<p><code>p ∨ q</code>表示命题p或命题q其中之一成立，或运算的定义为：</p>
<pre class="lean"><code>#print Or
-- inductive Or : Prop → Prop → Prop
-- number of parameters: 2
-- constructors:
-- Or.inl : ∀ {a b : Prop}, a → a ∨ b
-- Or.inr : ∀ {a b : Prop}, b → a ∨ b</code></pre>
<p>可以看到<code>Or</code>有两种构造函数，<code>inl</code>和<code>inr</code>。以<code>inl</code>为例，其含义为：若命题<code>a</code>成立，则命题<code>a ∨ b</code>成立。同理可知<code>inr</code>的用法。</p>
<div class="theorem example" id="exm-or-inl">
<p><span class="theorem-title"><strong>例 3</strong></span> <strong>Or.inl</strong></p>
<pre class="lean"><code>example {p q : Prop} : p → p ∨ q :=
  fun hp : p =&gt; Or.inl hp</code></pre>
</div>
<p>仿照这些例子，你可以完成下面的这些练习。</p>
<div class="theorem exercise" id="exr-or-inr">
<p><span class="theorem-title"><strong>习题 4</strong></span>  </p>
证明：<code>q → p ∨ q</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : q → p ∨ q :=
  fun hq : q =&gt; Or.inr hq</code></pre>
</details>
</div>
<p><code>p ∨ q</code>表明<code>p</code>和<code>q</code>中至少有一个为真，因此在证明过程中我们常常需要分情况讨论。对应的定理在Lean中为<code>Or.elim</code>. <code>Or.elim</code>的定义为：</p>
<pre class="lean"><code>#check Or.elim
-- Or.elim {a b c : Prop} (h : a ∨ b) (left : a → c) (right : b → c) : c</code></pre>
<p>即已知<code>a</code>和<code>b</code>中至少有一个为真，且分两种情况讨论都能推出<code>c</code>为真，那么<code>c</code>是真命题。</p>
<p><code>Or.elim</code>的用法举例如下：</p>
<div class="theorem exercise" id="exr-or-comm">
<p><span class="theorem-title"><strong>习题 5</strong></span>  </p>
<strong>或运算的交换律：</strong>证明: <code>p ∨ q → q ∨ p</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∨ q → q ∨ p :=
  fun hpq : p ∨ q =&gt;
    Or.elim hpq
      ( -- 假如p为真
        fun hp : p =&gt;
          Or.inr hp
      )
      ( -- 假如q为真
        fun hq : q =&gt;
          Or.inl hq
      )</code></pre>
</details>
</div>
</section>
<section class="level3" data-number="2.3.3" id="非運算">
<h3 class="anchored" data-anchor-id="非運算" data-number="2.3.3"><span class="header-section-number">2.3.3</span> 非运算</h3>
<p>Lean定义了两个特殊的命题，<code>True</code>和<code>False</code>. 它们分别代表真命题和假命题。</p>
<pre class="lean"><code>#check True  -- Prop
#check False -- Prop</code></pre>
<p>在Lean中，非运算的定义比较特别——它被定义为一个函数：</p>
<pre class="lean"><code>#print Not
-- def Not : Prop → Prop :=
-- fun a =&gt; a → False</code></pre>
<p>由Not的定义可见，非运算被定义为一个返回False命题的函数。即，如果<code>Not p</code>（或<code>¬p</code>）为真，那么我们以<code>p</code>为前提应该能得到一个假命题。</p>
<pre class="lean"><code>example {p q : Prop} : ¬p → ¬(p ∧ q) :=
  -- 当前目标为证明 ¬p → ¬(p ∧ q)
  fun hnp : ¬p =&gt;
    -- 此时目标为证明¬(p ∧ q)，等同于(p ∧ q) → False
    fun hpq : p ∧ q =&gt;
      -- 目标为`False`
      hnp hpq.left
      -- 👆hnp输入为`p`类型时，能返回False。我们利用这一点完成证明</code></pre>
<p>注意在这个例子中，<code>hnp</code>被当做一个函数使用，用于返回<code>False</code>类型。</p>
</section>
<section class="level3" data-number="2.3.4" id="等價關係">
<h3 class="anchored" data-anchor-id="等價關係" data-number="2.3.4"><span class="header-section-number">2.3.4</span> 等价关系</h3>
<p>当<code>p ↔︎ q</code>是，我们说<code>p</code>与<code>q</code>等价，或者<code>p</code>成立当且仅当<code>q</code>成立。等价关系被定义为：</p>
<pre class="lean"><code>#print Iff
-- structure Iff (a b : Prop) : Prop
-- number of parameters: 2
-- fields:
--   Iff.mp : a → b
--   Iff.mpr : b → a
-- constructor:
--   Iff.intro {a b : Prop} (mp : a → b) (mpr : b → a) : a ↔ b</code></pre>
<p>可以看到<code>Iff</code>是一个结构体，包含<code>mp</code>和<code>mpr</code>两个字段，并且有一个构造函数<code>Iff.intro</code>.</p>
<p><code>Iff.mp (p ↔︎ q)</code>，也可以写成<code>(p ↔︎ q).mp</code>，表示有<code>p → q</code>成立，即<code>p</code>为真时，<code>q</code>为真。反之<code>Iff.mpr (p ↔︎ q)</code>的箭头方向相反，表示<code>q → p</code>成立。</p>
<p><code>Iff.intro</code>的用法如下：</p>
<pre class="lean"><code>example {p q : Prop} : (p → q) → (q → p) → (p ↔ q) :=
  fun hpq : (p → q) =&gt;
    fun hqp : (q → p) =&gt;
      Iff.intro hpq hqp</code></pre>
</section>
</section>
<section class="level2" data-number="2.4" id="一些有用的工具">
<h2 class="anchored" data-anchor-id="一些有用的工具" data-number="2.4"><span class="header-section-number">2.4</span> 一些有用的工具</h2>
<section class="level3" data-number="2.4.1" id="show關鍵詞">
<h3 class="anchored" data-anchor-id="show關鍵詞" data-number="2.4.1"><span class="header-section-number">2.4.1</span> <code>show</code>关键词</h3>
<p>在Lean中，我们可以使用<code>show</code>关键词来指定我们要证明的类型。例如，</p>
<pre class="lean"><code>example {p q : Prop} : ¬p → ¬(p ∧ q) :=
  fun hnp : ¬p =&gt;
    show p ∧ q → False from
    fun hpq : p ∧ q =&gt;
      show False from hnp hpq.left</code></pre>
<p><code>show</code>的用处是增加我们代码的可读性。将当前证明目标显式展现出来。</p>
</section>
<section class="level3" data-number="2.4.2" id="let關鍵詞">
<h3 class="anchored" data-anchor-id="let關鍵詞" data-number="2.4.2"><span class="header-section-number">2.4.2</span> <code>let</code>关键词</h3>
<p><code>let</code>关键词用于局部变量的声明。例如，</p>
<pre class="lean"><code>example {p q : Prop} (h : p ∧ q) : q ∧ p :=
  let hp : p := h.left
  let hq : q := h.right
  show q ∧ p from And.intro hq hp</code></pre>
<p>在这个函数中，我们定义了<code>hp</code>和<code>hq</code>这两个局部变量。</p>
</section>
<section class="level3" data-number="2.4.3" id="have關鍵詞">
<h3 class="anchored" data-anchor-id="have關鍵詞" data-number="2.4.3"><span class="header-section-number">2.4.3</span> <code>have</code>关键词</h3>
<p>在Lean中，我们可以使用<code>have</code>关键词声明和完成一些中间步骤的证明。例如，</p>
<pre class="lean"><code>example {p q : Prop} (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left
  have hq : q := h.right
  show q ∧ p from And.intro hq hp</code></pre>
<p>在这个例子中，<code>hp</code>和<code>hq</code>是完成最终证明所需的中间步骤。</p>
<p>实际上<code>have</code>关键词是一种语法糖。<code>have h : p := s; t</code>等价于<code>(fun (h : p) =&gt; t) s</code>. 因此，上面的代码等价于：</p>
<pre class="lean"><code>example {p q : Prop} (h : p ∧ q) : q ∧ p :=
    (fun (hp : p) =&gt;
      (
        fun (hq : q) =&gt;
          show q ∧ p from And.intro hq hp
      ) h.right
    ) h.left</code></pre>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
注记
</div>
</div>
<div class="callout-body-container callout-body">
<p>请注意声明中间步骤的<code>have</code>和声明局部变量的<code>let</code>之间的差异，思考它们有什么区别。</p>
</div>
</div>
</section>
</section>
<section class="level2" data-number="2.5" id="練習一">
<h2 class="anchored" data-anchor-id="練習一" data-number="2.5"><span class="header-section-number">2.5</span> 练习一</h2>
<p>在证明下列命题时，请不要使用排中律，即（p ∨ ¬p）。</p>
<p>尽管在经典逻辑中，我们认为一个命题要么为真要么为假（排中律）；但也有一些人并不认可排中律，认为也应允许非真非假的命题存在。实际上，不依赖排中律我们也能完成许多定理的证明，包括下面这些定理。</p>
<div class="theorem exercise" id="exr-and-or-commu">
<p><span class="theorem-title"><strong>习题 6</strong></span>  </p>
<strong>∧和∨的交换律：</strong> 证明<code>p ∧ q ↔︎ q ∧ p</code>和 证明<code>p ∨ q ↔︎ q ∨ p</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∧ q ↔ q ∧ p :=
  Iff.intro
    (
      fun h : p ∧ q =&gt;
        have hp : p := h.left
        have hq : q := h.right
        And.intro hq hp
    )
    (
      fun h : q ∧ p =&gt;
        have hq : q := h.left
        have hp : p := h.right
        And.intro hp hq
    )

example {p q : Prop} : p ∨ q ↔ q ∨ p :=
  Iff.intro
    (
      fun h : p ∨ q =&gt;
        Or.elim h
          (fun hp : p =&gt; Or.intro_right q hp)
          (fun hq : q =&gt; Or.intro_left p hq)
    )
    (
      fun h : q ∨ p =&gt;
        Or.elim h
          (fun hq : q =&gt; Or.intro_right p hq)
          (fun hp : p =&gt; Or.intro_left q hp)
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-and-or-associativity">
<p><span class="theorem-title"><strong>习题 7</strong></span>  </p>
<strong>∧和∨的结合律：</strong> 证明：<code>example : (p ∧ q) ∧ r ↔︎ p ∧ (q ∧ r)</code>和 <code>example : (p ∨ q) ∨ r ↔︎ p ∨ (q ∨ r)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q r : Prop} : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) :=
  Iff.intro
    (
      fun h : (p ∧ q) ∧ r =&gt;
        let hpq : p ∧ q := h.left
        let hr : r := h.right
        let hp : p := hpq.left
        let hq : q := hpq.right
        And.intro hp (And.intro hq hr)
    )
    (
      fun h : p ∧ (q ∧ r) =&gt;
        let hp : p := h.left
        let hqr : q ∧ r := h.right
        let hq : q := hqr.left
        let hr : r := hqr.right
        And.intro (And.intro hp hq) hr
    )

example {p q r: Prop} : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) :=
  Iff.intro
    (
      fun h : (p ∨ q) ∨ r =&gt;
        Or.elim h
          (fun hpq : p ∨ q =&gt;
            Or.elim hpq
              (fun hp : p =&gt; Or.intro_left (q ∨ r) hp)
              (fun hq : q =&gt; Or.intro_right p (Or.intro_left r hq))
          )
          (fun hr : r =&gt; Or.intro_right p (Or.intro_right q hr))

    )
    (
      fun h : p ∨ (q ∨ r) =&gt;
        Or.elim h
          (fun hp: p =&gt; Or.intro_left r (Or.intro_left q hp))
          (fun hqr: q ∨ r =&gt;
            Or.elim hqr
              (fun hq : q =&gt; Or.intro_left r (Or.intro_right p hq))
              (fun hr : r =&gt; Or.intro_right (p ∨ q) hr)
          )
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-and-or-distributivity">
<p><span class="theorem-title"><strong>习题 8</strong></span>  </p>
<strong>∧和∨的分配律：</strong>证明<code>p ∧ (q ∨ r) ↔︎ (p ∧ q) ∨ (p ∧ r)</code> 和<code>p ∨ (q ∧ r) ↔︎ (p ∨ q) ∧ (p ∨ r)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q r: Prop} : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro
    (
      fun h : p ∧ (q ∨ r) =&gt;
        let hp: p := h.left
        let hqr: q ∨ r := h.right
        Or.elim hqr
          (fun hq : q =&gt; Or.intro_left (p ∧ r) (And.intro hp hq))
          (fun hr : r =&gt; Or.intro_right (p ∧ q) (And.intro hp hr))
    )
    (
      fun h : (p ∧ q) ∨ (p ∧ r) =&gt;
        Or.elim h
          (fun hpq : p ∧ q =&gt;
            let hp : p := hpq.left
            let hq : q := hpq.right
            And.intro hp (Or.intro_left r hq)
          )
          (fun hpr : p ∧ r =&gt;
            let hp := hpr.left
            let hr := hpr.right
            And.intro hp (Or.intro_right q hr)
          )
    )
example {p q r : Prop} : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) :=
  Iff.intro
    (
      fun h : p ∨ (q ∧ r) =&gt;
        Or.elim h
          (fun hp : p =&gt; And.intro (Or.intro_left q hp) (Or.intro_left r hp))
          (fun hqr : q ∧ r =&gt;
            have hq :q := hqr.left
            have hr :r := hqr.right
            And.intro (Or.intro_right p hq) (Or.intro_right p hr)
          )
    )
    (
      fun h : (p ∨ q) ∧ (p ∨ r) =&gt;
        have hpq : p ∨ q := h.left
        have hpr : p ∨ r := h.right
        Or.elim hpq
          (fun hp: p =&gt; Or.intro_left (q ∧ r) hp)
          (fun hq: q =&gt; Or.elim hpr
            (fun hp: p =&gt; Or.intro_left (q ∧ r) hp)
            (fun hr: r =&gt;
              have hqr : q ∧ r := And.intro hq hr
              Or.intro_right p hqr
            )
          )
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-1">
<p><span class="theorem-title"><strong>习题 9</strong></span> 证明：<code>(p → (q → r)) ↔︎ (p ∧ q → r)</code></p>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q r : Prop} : (p → (q → r)) ↔ (p ∧ q → r) :=
  Iff.intro
    (
      fun hpqr : p → (q → r) =&gt;
        fun hpq : p ∧ q =&gt;
          have hp := hpq.left
          have hq := hpq.right
          hpqr hp hq
    )
    (
      fun hpqr : p ∧ q → r =&gt;
        fun hp : p =&gt;
          fun hq : q =&gt;
            have hpq := And.intro hp hq
            hpqr hpq
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-2">
<p><span class="theorem-title"><strong>习题 10</strong></span>  </p>
证明：<code>((p ∨ q) → r) ↔︎ (p → r) ∧ (q → r)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q r : Prop} : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) :=
  Iff.intro
    (
      fun hpqr : p ∨ q → r =&gt;
        And.intro
          (fun hp : p =&gt; hpqr (Or.intro_left q hp))
          (fun hq : q =&gt; hpqr (Or.intro_right p hq))
    )
    (
      fun hprqr : (p → r) ∧ (q → r) =&gt;
        have hpr : p → r := hprqr.left
        have hqr : q → r := hprqr.right
        fun hpq : p ∨ q =&gt;
          Or.elim hpq
            (fun hp : p =&gt; hpr hp)
            (fun hq : q =&gt; hqr hq)
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-3">
<p><span class="theorem-title"><strong>习题 11</strong></span>  </p>
证明：<code>¬(p ∨ q) ↔︎ ¬p ∧ ¬q</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : ¬(p ∨ q) ↔ ¬p ∧ ¬q :=
  Iff.intro
    (
      fun hnpq : ¬(p ∨ q) =&gt;
        And.intro
          (fun hp : p =&gt; hnpq (Or.intro_left q hp))
          (fun hq : q =&gt; hnpq (Or.intro_right p hq))
    )
    (
      fun hnpnq : ¬p ∧ ¬q =&gt;
        have hnp : ¬p := hnpnq.left
        have hnq : ¬q := hnpnq.right
        (
          fun hpq : p ∨ q =&gt; Or.elim hpq
            (fun hp : p =&gt; hnp hp)
            (fun hq : q =&gt; hnq hq)
        )
    )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-4">
<p><span class="theorem-title"><strong>习题 12</strong></span>  </p>
证明：<code>¬p ∨ ¬q → ¬(p ∧ q)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : ¬p ∨ ¬q → ¬(p ∧ q) :=
  fun hnpnq : ¬p ∨ ¬q =&gt;
    Or.elim hnpnq
      (fun hnp : ¬p =&gt; fun hpq : p ∧ q =&gt; hnp hpq.left)
      (fun hnq : ¬q =&gt; fun hpq : p ∧ q =&gt; hnq hpq.right)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-5">
<p><span class="theorem-title"><strong>习题 13</strong></span>  </p>
证明：<code>¬(p ∧ ¬p)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p : Prop} : ¬(p ∧ ¬p) :=
  fun hpnp : p ∧ ¬p =&gt;
    have hp : p := hpnp.left
    have hnp: ¬p := hpnp.right
    hnp hp</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-6">
<p><span class="theorem-title"><strong>习题 14</strong></span>  </p>
证明：<code>p ∧ ¬q → ¬(p → q)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : p ∧ ¬q → ¬(p → q) :=
  fun hpnq : p ∧ ¬q =&gt;
    have hp : p := hpnq.left
    have hnq : ¬q := hpnq.right
    fun hpq : p → q =&gt;
      have hq : q := hpq hp
      hnq hq</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-7">
<p><span class="theorem-title"><strong>习题 15</strong></span>  </p>
证明：<code>¬p → (p → q)</code>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : ¬p → (p → q) :=
  fun hnp : ¬p =&gt;
    fun hp : p =&gt;
      False.elim (hnp hp)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-8">
<p><span class="theorem-title"><strong>习题 16</strong></span>  </p>
证明：(¬p ∨ q) → (p → q)
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : (¬p ∨ q) → (p → q) :=
  fun hnpq : ¬p ∨ q =&gt;
    fun hp : p =&gt;
      Or.elim hnpq
        (fun hnp : ¬p =&gt; False.elim (hnp hp))
        (fun hq : q =&gt; hq)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-9">
<p><span class="theorem-title"><strong>习题 17</strong></span>  </p>
<strong>同一律</strong>
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p : Prop} : p ∨ False ↔ p :=
  Iff.intro
    (
      fun hpf : p ∨ False =&gt;
      Or.elim hpf
        (fun hp : p =&gt; hp)
        (fun hf : False =&gt; False.elim hf)
    )
    (fun hp : p =&gt; Or.intro_left False hp)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-10">
<p><span class="theorem-title"><strong>习题 18</strong></span>  </p>
<strong>零律</strong> 证明：p ∧ False ↔︎ False
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p : Prop} : p ∧ False ↔ False :=
  Iff.intro
    (
      fun hpf : p ∧ False =&gt;
        have hf : False := hpf.right
        hf
    )
    fun hf : False =&gt;
      False.elim hf</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-11">
<p><span class="theorem-title"><strong>习题 19</strong></span>  </p>
<strong>假言易位</strong> 证明：(p → q) → (¬q → ¬p)
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>example {p q : Prop} : (p → q) → (¬q → ¬p) :=
  fun (hpq : p → q) (hnq : ¬q) =&gt;
    fun hp : p =&gt;
      hnq (hpq hp)</code></pre>
</details>
</div>
</section>
<section class="level2" data-number="2.6" id="練習二-經典邏輯">
<h2 class="anchored" data-anchor-id="練習二-經典邏輯" data-number="2.6"><span class="header-section-number">2.6</span> 练习二-经典逻辑</h2>
<p>下面的练习中，你可以使用排中律。</p>
<p>Lean中，排中律位于<code>Classical</code>命名空间下。</p>
<pre class="lean"><code>#check Classical.em</code></pre>
<p>我们可以临时地使用Classical命名空间，而不干扰其它代码。方法为<code>open Classical in ...</code>，例如</p>
<pre class="lean"><code>open Classical in
example {p : Prop} : p ∨ ¬p := em p</code></pre>
<p>允许使用排中律，使得你可以分正反两种情形分析问题。这对应<code>Classical</code>命名空间下的<code>byCases</code>定理：</p>
<pre class="lean"><code>#check Classical.byCases
-- Classical.byCases {p q : Prop} (hpq : p → q) (hnpq : ¬p → q) : q</code></pre>
<p>即如果分正反两种情况讨论，都有结论成立，说明结论成立。</p>
<div class="theorem exercise" id="exr-property-12">
<p><span class="theorem-title"><strong>习题 20</strong></span>  </p>
证明：(p → q ∨ r) → ((p → q) ∨ (p → r))
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q r : Prop} : (p → q ∨ r) → ((p → q) ∨ (p → r)) :=
  fun pqr : p → q ∨ r =&gt;
    Or.elim (em q)
    (
      fun hq : q =&gt;
        Or.intro_left (p → r) (fun _ : p =&gt; hq)
    )
    (
      fun hnq : ¬q =&gt;
        Or.intro_right (p → q)
        (
          fun hp : p =&gt;
            have qr : q ∨ r := pqr hp
            Or.elim qr
              (fun hq : q =&gt; False.elim (hnq hq))
              (fun hr : r =&gt; hr

        )
    )
  )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-13">
<p><span class="theorem-title"><strong>习题 21</strong></span>  </p>
证明：¬(p ∧ q) → ¬p ∨ ¬q
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : ¬(p ∧ q) → ¬p ∨ ¬q :=
  fun hnpq : ¬(p ∧ q) =&gt;
    byCases
      (
        fun hp : p =&gt;
          byCases
            (
              fun (hq : q) =&gt;
                have hpq : p ∧ q := And.intro hp hq
                absurd hpq hnpq
            )
            (fun (hnq : ¬q) =&gt; Or.intro_right (¬p) hnq)
      )
      (fun hnp : ¬p =&gt; Or.intro_left (¬q) hnp)</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-14">
<p><span class="theorem-title"><strong>习题 22</strong></span>  </p>
证明：(p → q) → (¬p ∨ q)
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : (p → q) → (¬p ∨ q) :=
  fun hpq : (p → q) =&gt;
    byCases
      (
        fun hp : p =&gt;
          have hq : q := hpq hp
          Or.intro_right (¬p) hq
      )
      (
        fun hnp : ¬p =&gt; Or.intro_left q hnp
      )</code></pre>
</details>
</div>
<div class="theorem exercise" id="exr-property-15">
<p><span class="theorem-title"><strong>习题 23</strong></span>  </p>
证明：(¬q → ¬p) → (p → q)
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : (¬q → ¬p) → (p → q) :=
  fun hnqnp : ¬q → ¬p =&gt;
    fun hp : p =&gt;
      Or.elim (em q)
        (fun hq : q =&gt; hq)
        (
          fun hnq : ¬q =&gt;
            have hnp : ¬p := hnqnp hnq
            False.elim (hnp hp)
        )</code></pre>
</details>
</div>
<div class="theorem example" id="exm-property-17">
<p><span class="theorem-title"><strong>例 4</strong></span>  </p>
证明：(((p → q) → p) → p)
<details>
<summary>
参考答案
</summary>
<pre class="lean"><code>open Classical in
example {p q : Prop} : (((p → q) → p) → p) :=
  fun hpqp : (p → q) → p =&gt;
    byCases
      (fun hp : p =&gt; hp)
      (
        fun hnp : ¬p =&gt;
          have hpq : p → q := (fun hp : p =&gt; False.elim (hnp hp))
          have hp : p := hpqp hpq
          False.elim (hnp hp)
      )</code></pre>
</details>
</div>
</section>
</section>
<section class="level1" data-number="3" id="總結">

<p>也许现在告诉你有点太迟，但其实一般的命题逻辑都可以由<code>tauto</code>策略自动证明。如下所示，</p>
<pre class="lean"><code>-- example {p q r: Prop} : (p → (q → r)) ↔ (p ∧ q → r) := by tauto
-- 注意：使用tauto的前提是import Mathlib</code></pre>
<p>至此，本章介绍了Lean中命题逻辑的基础知识，希望你已经理解在Lean中如何引用定理，显式地构造一个命题的证明，或者使用<code>tauto</code>策略自动完成命题逻辑的证明。</p>
</section>
</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
</div>
    </div>
    <div class="post_list">
        <span>By </span>
        <a href="./">@執迷</a>
        <span> in </span>
        <span class="post_category"><a href="./" rel="bookmark" title="Permalink to Lean 4">[ Lean 4 ]</a></span>
        <span class="post_date">2025-01-12</span>
        <div><span>Tags : </span>
            
            
            <span><a href="./">#Lean, </a></span>
            
            <span><a href="./">#自動證明器, </a></span>
            
            <span><a href="./">#數學, </a></span>
            
            <span><a href="./">#命題邏輯, </a></span>
            
            
        </div>

        <div class="entry-social">
            <span class="twitter"><a target="_blank" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;" title="Twitter" href="https://twitter.com/share?url=././lean_logic_20250111_zh-cn.html&text=Lean语言数学之旅——命题逻辑&via="><img src="./theme/images/icons/twitter-s.png"></a></span>

            <span class="gplus"><a target="_blank" title="Google +" href="https://plus.google.com/share?url=././lean_logic_20250111_zh-cn.html&hl=fr" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="./theme/images/icons/google-s.png"></a></span>

            <span class="facebook"><a target="_blank" title="Facebook" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=500,width=700');return false;" href="https://www.facebook.com/sharer.php?u=././lean_logic_20250111_zh-cn.html&t=Lean语言数学之旅——命题逻辑"><img src="./theme/images/icons/facebook-s.png"></a></span>

            <a  target="_blank" title="Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=././lean_logic_20250111_zh-cn.html&title=Lean语言数学之旅——命题逻辑" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="./theme/images/icons/linkedin-s.png"></a>

            <span class="mail"><a href="mailto:?subject=Lean语言数学之旅——命题逻辑&amp;body=Viens découvrir un article à propos de [Lean语言数学之旅——命题逻辑] sur le site de 執迷. ././lean_logic_20250111_zh-cn.html" title="Share by Email" target="_blank"><img src="./theme/images/icons/mail-s.png"></a></span>
        </div>
    </div>
    

</section>

<!-- Quarto Clipboard -->
<script type="text/javascript">
    var clipboard = new ClipboardJS(
        '.code-copy-button',
        {
            target: function(trigger) {
                console.log("Copy texts. ", trigger);
                return trigger.previousElementSibling;
            }
        }
    );    
    clipboard.on('success', function(e) {
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        e.clearSelection();
        alert('Copied!');
    });
    console.log("ClipboardJS loaded.");
</script>

  </article>

  <!-- Footer -->
  <footer>
    <p>
      Blog powered by <a href="http://getpelican.com/">Pelican</a>, 
      which takes great advantage of <a href="http://python.org">Python</a>.
      Theme <a href="https://github.com/parbhat/pelican-blue">Pelican-Blue</a> by <a href="https://parbhatpuri.com/">@parbhat</a>.
    </p>
    
      
      <span id="busuanzi_container_site_pv">總訪問量<span id="busuanzi_value_site_pv"></span></span>
      <span id="busuanzi_container_site_uv">
        訪客數<span id="busuanzi_value_site_uv"></span>
      </span>
      
    
  </footer>
</body>
</html>